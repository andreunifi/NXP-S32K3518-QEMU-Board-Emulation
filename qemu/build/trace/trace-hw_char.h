/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_CHAR_GENERATED_TRACERS_H
#define TRACE_HW_CHAR_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_PARALLEL_IOPORT_READ_EVENT;
extern TraceEvent _TRACE_PARALLEL_IOPORT_WRITE_EVENT;
extern TraceEvent _TRACE_SERIAL_READ_EVENT;
extern TraceEvent _TRACE_SERIAL_WRITE_EVENT;
extern TraceEvent _TRACE_SERIAL_UPDATE_PARAMETERS_EVENT;
extern TraceEvent _TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT_EVENT;
extern TraceEvent _TRACE_VIRTIO_SERIAL_THROTTLE_PORT_EVENT;
extern TraceEvent _TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_EVENT;
extern TraceEvent _TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT_EVENT;
extern TraceEvent _TRACE_VIRTIO_CONSOLE_FLUSH_BUF_EVENT;
extern TraceEvent _TRACE_VIRTIO_CONSOLE_CHR_READ_EVENT;
extern TraceEvent _TRACE_VIRTIO_CONSOLE_CHR_EVENT_EVENT;
extern TraceEvent _TRACE_GOLDFISH_TTY_READ_EVENT;
extern TraceEvent _TRACE_GOLDFISH_TTY_WRITE_EVENT;
extern TraceEvent _TRACE_GOLDFISH_TTY_CAN_RECEIVE_EVENT;
extern TraceEvent _TRACE_GOLDFISH_TTY_RECEIVE_EVENT;
extern TraceEvent _TRACE_GOLDFISH_TTY_RESET_EVENT;
extern TraceEvent _TRACE_GOLDFISH_TTY_REALIZE_EVENT;
extern TraceEvent _TRACE_GOLDFISH_TTY_UNREALIZE_EVENT;
extern TraceEvent _TRACE_GOLDFISH_TTY_INSTANCE_INIT_EVENT;
extern TraceEvent _TRACE_GRLIB_APBUART_EVENT_EVENT;
extern TraceEvent _TRACE_GRLIB_APBUART_WRITEL_UNKNOWN_EVENT;
extern TraceEvent _TRACE_GRLIB_APBUART_READL_UNKNOWN_EVENT;
extern TraceEvent _TRACE_ESCC_HARD_RESET_EVENT;
extern TraceEvent _TRACE_ESCC_SOFT_RESET_CHN_EVENT;
extern TraceEvent _TRACE_ESCC_PUT_QUEUE_EVENT;
extern TraceEvent _TRACE_ESCC_GET_QUEUE_EVENT;
extern TraceEvent _TRACE_ESCC_UPDATE_IRQ_EVENT;
extern TraceEvent _TRACE_ESCC_UPDATE_PARAMETERS_EVENT;
extern TraceEvent _TRACE_ESCC_MEM_WRITEB_CTRL_EVENT;
extern TraceEvent _TRACE_ESCC_MEM_WRITEB_DATA_EVENT;
extern TraceEvent _TRACE_ESCC_MEM_READB_CTRL_EVENT;
extern TraceEvent _TRACE_ESCC_MEM_READB_DATA_EVENT;
extern TraceEvent _TRACE_ESCC_SERIAL_RECEIVE_BYTE_EVENT;
extern TraceEvent _TRACE_ESCC_SUNKBD_EVENT_IN_EVENT;
extern TraceEvent _TRACE_ESCC_SUNKBD_EVENT_OUT_EVENT;
extern TraceEvent _TRACE_ESCC_KBD_COMMAND_EVENT;
extern TraceEvent _TRACE_ESCC_SUNMOUSE_EVENT_EVENT;
extern TraceEvent _TRACE_IMX_SERIAL_READ_EVENT;
extern TraceEvent _TRACE_IMX_SERIAL_WRITE_EVENT;
extern TraceEvent _TRACE_IMX_SERIAL_PUT_DATA_EVENT;
extern TraceEvent _TRACE_PL011_IRQ_STATE_EVENT;
extern TraceEvent _TRACE_PL011_READ_EVENT;
extern TraceEvent _TRACE_PL011_READ_FIFO_EVENT;
extern TraceEvent _TRACE_PL011_WRITE_EVENT;
extern TraceEvent _TRACE_PL011_CAN_RECEIVE_EVENT;
extern TraceEvent _TRACE_PL011_FIFO_RX_PUT_EVENT;
extern TraceEvent _TRACE_PL011_FIFO_RX_FULL_EVENT;
extern TraceEvent _TRACE_PL011_BAUDRATE_CHANGE_EVENT;
extern TraceEvent _TRACE_PL011_RECEIVE_EVENT;
extern TraceEvent _TRACE_NXP_UART_IRQ_STATE_EVENT;
extern TraceEvent _TRACE_NXP_UART_READ_EVENT;
extern TraceEvent _TRACE_NXP_UART_READ_FIFO_EVENT;
extern TraceEvent _TRACE_NXP_UART_WRITE_EVENT;
extern TraceEvent _TRACE_NXP_UART_CAN_RECEIVE_EVENT;
extern TraceEvent _TRACE_NXP_UART_FIFO_RX_PUT_EVENT;
extern TraceEvent _TRACE_NXP_UART_FIFO_RX_FULL_EVENT;
extern TraceEvent _TRACE_NXP_UART_BAUDRATE_CHANGE_EVENT;
extern TraceEvent _TRACE_NXP_UART_RECEIVE_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_READ_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_WRITE_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_RESET_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_RECEIVE_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_TX_PENDING_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_TX_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_SET_PARAMS_EVENT;
extern TraceEvent _TRACE_NRF51_UART_READ_EVENT;
extern TraceEvent _TRACE_NRF51_UART_WRITE_EVENT;
extern TraceEvent _TRACE_SHAKTI_UART_READ_EVENT;
extern TraceEvent _TRACE_SHAKTI_UART_WRITE_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_DMABUSY_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_DMAREADY_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_IRQ_RAISED_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_IRQ_LOWERED_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_UPDATE_PARAMS_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_WRITE_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_READ_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_RX_FIFO_RESET_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_TX_FIFO_RESET_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_TX_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_INTCLR_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_RO_WRITE_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_RX_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_RX_ERROR_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_WO_READ_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_RXSIZE_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_CHANNEL_ERROR_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_RX_TIMEOUT_EVENT;
extern TraceEvent _TRACE_CADENCE_UART_BAUDRATE_EVENT;
extern TraceEvent _TRACE_SH_SERIAL_READ_EVENT;
extern TraceEvent _TRACE_SH_SERIAL_WRITE_EVENT;
extern TraceEvent _TRACE_STM32L4X5_USART_READ_EVENT;
extern TraceEvent _TRACE_STM32L4X5_USART_WRITE_EVENT;
extern TraceEvent _TRACE_STM32L4X5_USART_RX_EVENT;
extern TraceEvent _TRACE_STM32L4X5_USART_TX_EVENT;
extern TraceEvent _TRACE_STM32L4X5_USART_TX_PENDING_EVENT;
extern TraceEvent _TRACE_STM32L4X5_USART_IRQ_RAISED_EVENT;
extern TraceEvent _TRACE_STM32L4X5_USART_IRQ_LOWERED_EVENT;
extern TraceEvent _TRACE_STM32L4X5_USART_OVERRUN_DETECTED_EVENT;
extern TraceEvent _TRACE_STM32L4X5_USART_RECEIVER_NOT_ENABLED_EVENT;
extern TraceEvent _TRACE_STM32L4X5_USART_UPDATE_PARAMS_EVENT;
extern TraceEvent _TRACE_XEN_CONSOLE_CONNECT_EVENT;
extern TraceEvent _TRACE_XEN_CONSOLE_DISCONNECT_EVENT;
extern TraceEvent _TRACE_XEN_CONSOLE_UNREALIZE_EVENT;
extern TraceEvent _TRACE_XEN_CONSOLE_REALIZE_EVENT;
extern TraceEvent _TRACE_XEN_CONSOLE_DEVICE_CREATE_EVENT;
extern TraceEvent _TRACE_XEN_CONSOLE_DEVICE_DESTROY_EVENT;
extern TraceEvent _TRACE_STM32F2XX_USART_READ_EVENT;
extern TraceEvent _TRACE_STM32F2XX_USART_WRITE_EVENT;
extern TraceEvent _TRACE_STM32F2XX_USART_DROP_EVENT;
extern TraceEvent _TRACE_STM32F2XX_USART_RECEIVE_EVENT;
extern TraceEvent _TRACE_HTIF_UART_WRITE_TO_HOST_EVENT;
extern TraceEvent _TRACE_HTIF_UART_UNKNOWN_DEVICE_COMMAND_EVENT;
extern uint16_t _TRACE_PARALLEL_IOPORT_READ_DSTATE;
extern uint16_t _TRACE_PARALLEL_IOPORT_WRITE_DSTATE;
extern uint16_t _TRACE_SERIAL_READ_DSTATE;
extern uint16_t _TRACE_SERIAL_WRITE_DSTATE;
extern uint16_t _TRACE_SERIAL_UPDATE_PARAMETERS_DSTATE;
extern uint16_t _TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT_DSTATE;
extern uint16_t _TRACE_VIRTIO_SERIAL_THROTTLE_PORT_DSTATE;
extern uint16_t _TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_DSTATE;
extern uint16_t _TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT_DSTATE;
extern uint16_t _TRACE_VIRTIO_CONSOLE_FLUSH_BUF_DSTATE;
extern uint16_t _TRACE_VIRTIO_CONSOLE_CHR_READ_DSTATE;
extern uint16_t _TRACE_VIRTIO_CONSOLE_CHR_EVENT_DSTATE;
extern uint16_t _TRACE_GOLDFISH_TTY_READ_DSTATE;
extern uint16_t _TRACE_GOLDFISH_TTY_WRITE_DSTATE;
extern uint16_t _TRACE_GOLDFISH_TTY_CAN_RECEIVE_DSTATE;
extern uint16_t _TRACE_GOLDFISH_TTY_RECEIVE_DSTATE;
extern uint16_t _TRACE_GOLDFISH_TTY_RESET_DSTATE;
extern uint16_t _TRACE_GOLDFISH_TTY_REALIZE_DSTATE;
extern uint16_t _TRACE_GOLDFISH_TTY_UNREALIZE_DSTATE;
extern uint16_t _TRACE_GOLDFISH_TTY_INSTANCE_INIT_DSTATE;
extern uint16_t _TRACE_GRLIB_APBUART_EVENT_DSTATE;
extern uint16_t _TRACE_GRLIB_APBUART_WRITEL_UNKNOWN_DSTATE;
extern uint16_t _TRACE_GRLIB_APBUART_READL_UNKNOWN_DSTATE;
extern uint16_t _TRACE_ESCC_HARD_RESET_DSTATE;
extern uint16_t _TRACE_ESCC_SOFT_RESET_CHN_DSTATE;
extern uint16_t _TRACE_ESCC_PUT_QUEUE_DSTATE;
extern uint16_t _TRACE_ESCC_GET_QUEUE_DSTATE;
extern uint16_t _TRACE_ESCC_UPDATE_IRQ_DSTATE;
extern uint16_t _TRACE_ESCC_UPDATE_PARAMETERS_DSTATE;
extern uint16_t _TRACE_ESCC_MEM_WRITEB_CTRL_DSTATE;
extern uint16_t _TRACE_ESCC_MEM_WRITEB_DATA_DSTATE;
extern uint16_t _TRACE_ESCC_MEM_READB_CTRL_DSTATE;
extern uint16_t _TRACE_ESCC_MEM_READB_DATA_DSTATE;
extern uint16_t _TRACE_ESCC_SERIAL_RECEIVE_BYTE_DSTATE;
extern uint16_t _TRACE_ESCC_SUNKBD_EVENT_IN_DSTATE;
extern uint16_t _TRACE_ESCC_SUNKBD_EVENT_OUT_DSTATE;
extern uint16_t _TRACE_ESCC_KBD_COMMAND_DSTATE;
extern uint16_t _TRACE_ESCC_SUNMOUSE_EVENT_DSTATE;
extern uint16_t _TRACE_IMX_SERIAL_READ_DSTATE;
extern uint16_t _TRACE_IMX_SERIAL_WRITE_DSTATE;
extern uint16_t _TRACE_IMX_SERIAL_PUT_DATA_DSTATE;
extern uint16_t _TRACE_PL011_IRQ_STATE_DSTATE;
extern uint16_t _TRACE_PL011_READ_DSTATE;
extern uint16_t _TRACE_PL011_READ_FIFO_DSTATE;
extern uint16_t _TRACE_PL011_WRITE_DSTATE;
extern uint16_t _TRACE_PL011_CAN_RECEIVE_DSTATE;
extern uint16_t _TRACE_PL011_FIFO_RX_PUT_DSTATE;
extern uint16_t _TRACE_PL011_FIFO_RX_FULL_DSTATE;
extern uint16_t _TRACE_PL011_BAUDRATE_CHANGE_DSTATE;
extern uint16_t _TRACE_PL011_RECEIVE_DSTATE;
extern uint16_t _TRACE_NXP_UART_IRQ_STATE_DSTATE;
extern uint16_t _TRACE_NXP_UART_READ_DSTATE;
extern uint16_t _TRACE_NXP_UART_READ_FIFO_DSTATE;
extern uint16_t _TRACE_NXP_UART_WRITE_DSTATE;
extern uint16_t _TRACE_NXP_UART_CAN_RECEIVE_DSTATE;
extern uint16_t _TRACE_NXP_UART_FIFO_RX_PUT_DSTATE;
extern uint16_t _TRACE_NXP_UART_FIFO_RX_FULL_DSTATE;
extern uint16_t _TRACE_NXP_UART_BAUDRATE_CHANGE_DSTATE;
extern uint16_t _TRACE_NXP_UART_RECEIVE_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_READ_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_WRITE_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_RESET_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_RECEIVE_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_TX_PENDING_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_TX_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_SET_PARAMS_DSTATE;
extern uint16_t _TRACE_NRF51_UART_READ_DSTATE;
extern uint16_t _TRACE_NRF51_UART_WRITE_DSTATE;
extern uint16_t _TRACE_SHAKTI_UART_READ_DSTATE;
extern uint16_t _TRACE_SHAKTI_UART_WRITE_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_DMABUSY_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_DMAREADY_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_IRQ_RAISED_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_IRQ_LOWERED_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_UPDATE_PARAMS_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_WRITE_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_READ_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_RX_FIFO_RESET_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_TX_FIFO_RESET_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_TX_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_INTCLR_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_RO_WRITE_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_RX_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_RX_ERROR_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_WO_READ_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_RXSIZE_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_CHANNEL_ERROR_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_RX_TIMEOUT_DSTATE;
extern uint16_t _TRACE_CADENCE_UART_BAUDRATE_DSTATE;
extern uint16_t _TRACE_SH_SERIAL_READ_DSTATE;
extern uint16_t _TRACE_SH_SERIAL_WRITE_DSTATE;
extern uint16_t _TRACE_STM32L4X5_USART_READ_DSTATE;
extern uint16_t _TRACE_STM32L4X5_USART_WRITE_DSTATE;
extern uint16_t _TRACE_STM32L4X5_USART_RX_DSTATE;
extern uint16_t _TRACE_STM32L4X5_USART_TX_DSTATE;
extern uint16_t _TRACE_STM32L4X5_USART_TX_PENDING_DSTATE;
extern uint16_t _TRACE_STM32L4X5_USART_IRQ_RAISED_DSTATE;
extern uint16_t _TRACE_STM32L4X5_USART_IRQ_LOWERED_DSTATE;
extern uint16_t _TRACE_STM32L4X5_USART_OVERRUN_DETECTED_DSTATE;
extern uint16_t _TRACE_STM32L4X5_USART_RECEIVER_NOT_ENABLED_DSTATE;
extern uint16_t _TRACE_STM32L4X5_USART_UPDATE_PARAMS_DSTATE;
extern uint16_t _TRACE_XEN_CONSOLE_CONNECT_DSTATE;
extern uint16_t _TRACE_XEN_CONSOLE_DISCONNECT_DSTATE;
extern uint16_t _TRACE_XEN_CONSOLE_UNREALIZE_DSTATE;
extern uint16_t _TRACE_XEN_CONSOLE_REALIZE_DSTATE;
extern uint16_t _TRACE_XEN_CONSOLE_DEVICE_CREATE_DSTATE;
extern uint16_t _TRACE_XEN_CONSOLE_DEVICE_DESTROY_DSTATE;
extern uint16_t _TRACE_STM32F2XX_USART_READ_DSTATE;
extern uint16_t _TRACE_STM32F2XX_USART_WRITE_DSTATE;
extern uint16_t _TRACE_STM32F2XX_USART_DROP_DSTATE;
extern uint16_t _TRACE_STM32F2XX_USART_RECEIVE_DSTATE;
extern uint16_t _TRACE_HTIF_UART_WRITE_TO_HOST_DSTATE;
extern uint16_t _TRACE_HTIF_UART_UNKNOWN_DEVICE_COMMAND_DSTATE;
#define TRACE_PARALLEL_IOPORT_READ_ENABLED 1
#define TRACE_PARALLEL_IOPORT_WRITE_ENABLED 1
#define TRACE_SERIAL_READ_ENABLED 1
#define TRACE_SERIAL_WRITE_ENABLED 1
#define TRACE_SERIAL_UPDATE_PARAMETERS_ENABLED 1
#define TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT_ENABLED 1
#define TRACE_VIRTIO_SERIAL_THROTTLE_PORT_ENABLED 1
#define TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_ENABLED 1
#define TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT_ENABLED 1
#define TRACE_VIRTIO_CONSOLE_FLUSH_BUF_ENABLED 1
#define TRACE_VIRTIO_CONSOLE_CHR_READ_ENABLED 1
#define TRACE_VIRTIO_CONSOLE_CHR_EVENT_ENABLED 1
#define TRACE_GOLDFISH_TTY_READ_ENABLED 1
#define TRACE_GOLDFISH_TTY_WRITE_ENABLED 1
#define TRACE_GOLDFISH_TTY_CAN_RECEIVE_ENABLED 1
#define TRACE_GOLDFISH_TTY_RECEIVE_ENABLED 1
#define TRACE_GOLDFISH_TTY_RESET_ENABLED 1
#define TRACE_GOLDFISH_TTY_REALIZE_ENABLED 1
#define TRACE_GOLDFISH_TTY_UNREALIZE_ENABLED 1
#define TRACE_GOLDFISH_TTY_INSTANCE_INIT_ENABLED 1
#define TRACE_GRLIB_APBUART_EVENT_ENABLED 1
#define TRACE_GRLIB_APBUART_WRITEL_UNKNOWN_ENABLED 1
#define TRACE_GRLIB_APBUART_READL_UNKNOWN_ENABLED 1
#define TRACE_ESCC_HARD_RESET_ENABLED 1
#define TRACE_ESCC_SOFT_RESET_CHN_ENABLED 1
#define TRACE_ESCC_PUT_QUEUE_ENABLED 1
#define TRACE_ESCC_GET_QUEUE_ENABLED 1
#define TRACE_ESCC_UPDATE_IRQ_ENABLED 1
#define TRACE_ESCC_UPDATE_PARAMETERS_ENABLED 1
#define TRACE_ESCC_MEM_WRITEB_CTRL_ENABLED 1
#define TRACE_ESCC_MEM_WRITEB_DATA_ENABLED 1
#define TRACE_ESCC_MEM_READB_CTRL_ENABLED 1
#define TRACE_ESCC_MEM_READB_DATA_ENABLED 1
#define TRACE_ESCC_SERIAL_RECEIVE_BYTE_ENABLED 1
#define TRACE_ESCC_SUNKBD_EVENT_IN_ENABLED 1
#define TRACE_ESCC_SUNKBD_EVENT_OUT_ENABLED 1
#define TRACE_ESCC_KBD_COMMAND_ENABLED 1
#define TRACE_ESCC_SUNMOUSE_EVENT_ENABLED 1
#define TRACE_IMX_SERIAL_READ_ENABLED 1
#define TRACE_IMX_SERIAL_WRITE_ENABLED 1
#define TRACE_IMX_SERIAL_PUT_DATA_ENABLED 1
#define TRACE_PL011_IRQ_STATE_ENABLED 1
#define TRACE_PL011_READ_ENABLED 1
#define TRACE_PL011_READ_FIFO_ENABLED 1
#define TRACE_PL011_WRITE_ENABLED 1
#define TRACE_PL011_CAN_RECEIVE_ENABLED 1
#define TRACE_PL011_FIFO_RX_PUT_ENABLED 1
#define TRACE_PL011_FIFO_RX_FULL_ENABLED 1
#define TRACE_PL011_BAUDRATE_CHANGE_ENABLED 1
#define TRACE_PL011_RECEIVE_ENABLED 1
#define TRACE_NXP_UART_IRQ_STATE_ENABLED 1
#define TRACE_NXP_UART_READ_ENABLED 1
#define TRACE_NXP_UART_READ_FIFO_ENABLED 1
#define TRACE_NXP_UART_WRITE_ENABLED 1
#define TRACE_NXP_UART_CAN_RECEIVE_ENABLED 1
#define TRACE_NXP_UART_FIFO_RX_PUT_ENABLED 1
#define TRACE_NXP_UART_FIFO_RX_FULL_ENABLED 1
#define TRACE_NXP_UART_BAUDRATE_CHANGE_ENABLED 1
#define TRACE_NXP_UART_RECEIVE_ENABLED 1
#define TRACE_CMSDK_APB_UART_READ_ENABLED 1
#define TRACE_CMSDK_APB_UART_WRITE_ENABLED 1
#define TRACE_CMSDK_APB_UART_RESET_ENABLED 1
#define TRACE_CMSDK_APB_UART_RECEIVE_ENABLED 1
#define TRACE_CMSDK_APB_UART_TX_PENDING_ENABLED 1
#define TRACE_CMSDK_APB_UART_TX_ENABLED 1
#define TRACE_CMSDK_APB_UART_SET_PARAMS_ENABLED 1
#define TRACE_NRF51_UART_READ_ENABLED 1
#define TRACE_NRF51_UART_WRITE_ENABLED 1
#define TRACE_SHAKTI_UART_READ_ENABLED 1
#define TRACE_SHAKTI_UART_WRITE_ENABLED 1
#define TRACE_EXYNOS_UART_DMABUSY_ENABLED 1
#define TRACE_EXYNOS_UART_DMAREADY_ENABLED 1
#define TRACE_EXYNOS_UART_IRQ_RAISED_ENABLED 1
#define TRACE_EXYNOS_UART_IRQ_LOWERED_ENABLED 1
#define TRACE_EXYNOS_UART_UPDATE_PARAMS_ENABLED 1
#define TRACE_EXYNOS_UART_WRITE_ENABLED 1
#define TRACE_EXYNOS_UART_READ_ENABLED 1
#define TRACE_EXYNOS_UART_RX_FIFO_RESET_ENABLED 1
#define TRACE_EXYNOS_UART_TX_FIFO_RESET_ENABLED 1
#define TRACE_EXYNOS_UART_TX_ENABLED 1
#define TRACE_EXYNOS_UART_INTCLR_ENABLED 1
#define TRACE_EXYNOS_UART_RO_WRITE_ENABLED 1
#define TRACE_EXYNOS_UART_RX_ENABLED 1
#define TRACE_EXYNOS_UART_RX_ERROR_ENABLED 1
#define TRACE_EXYNOS_UART_WO_READ_ENABLED 1
#define TRACE_EXYNOS_UART_RXSIZE_ENABLED 1
#define TRACE_EXYNOS_UART_CHANNEL_ERROR_ENABLED 1
#define TRACE_EXYNOS_UART_RX_TIMEOUT_ENABLED 1
#define TRACE_CADENCE_UART_BAUDRATE_ENABLED 1
#define TRACE_SH_SERIAL_READ_ENABLED 1
#define TRACE_SH_SERIAL_WRITE_ENABLED 1
#define TRACE_STM32L4X5_USART_READ_ENABLED 1
#define TRACE_STM32L4X5_USART_WRITE_ENABLED 1
#define TRACE_STM32L4X5_USART_RX_ENABLED 1
#define TRACE_STM32L4X5_USART_TX_ENABLED 1
#define TRACE_STM32L4X5_USART_TX_PENDING_ENABLED 1
#define TRACE_STM32L4X5_USART_IRQ_RAISED_ENABLED 1
#define TRACE_STM32L4X5_USART_IRQ_LOWERED_ENABLED 1
#define TRACE_STM32L4X5_USART_OVERRUN_DETECTED_ENABLED 1
#define TRACE_STM32L4X5_USART_RECEIVER_NOT_ENABLED_ENABLED 1
#define TRACE_STM32L4X5_USART_UPDATE_PARAMS_ENABLED 1
#define TRACE_XEN_CONSOLE_CONNECT_ENABLED 1
#define TRACE_XEN_CONSOLE_DISCONNECT_ENABLED 1
#define TRACE_XEN_CONSOLE_UNREALIZE_ENABLED 1
#define TRACE_XEN_CONSOLE_REALIZE_ENABLED 1
#define TRACE_XEN_CONSOLE_DEVICE_CREATE_ENABLED 1
#define TRACE_XEN_CONSOLE_DEVICE_DESTROY_ENABLED 1
#define TRACE_STM32F2XX_USART_READ_ENABLED 1
#define TRACE_STM32F2XX_USART_WRITE_ENABLED 1
#define TRACE_STM32F2XX_USART_DROP_ENABLED 1
#define TRACE_STM32F2XX_USART_RECEIVE_ENABLED 1
#define TRACE_HTIF_UART_WRITE_TO_HOST_ENABLED 1
#define TRACE_HTIF_UART_UNKNOWN_DEVICE_COMMAND_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_PARALLEL_IOPORT_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PARALLEL_IOPORT_READ) || \
    false)

static inline void _nocheck__trace_parallel_ioport_read(const char * desc, uint16_t addr, uint8_t value)
{
    if (trace_event_get_state(TRACE_PARALLEL_IOPORT_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:parallel_ioport_read " "read [%s] addr 0x%02x val 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , desc, addr, value);
#line 367 "trace/trace-hw_char.h"
        } else {
#line 4 "../hw/char/trace-events"
            qemu_log("parallel_ioport_read " "read [%s] addr 0x%02x val 0x%02x" "\n", desc, addr, value);
#line 371 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_parallel_ioport_read(const char * desc, uint16_t addr, uint8_t value)
{
    if (true) {
        _nocheck__trace_parallel_ioport_read(desc, addr, value);
    }
}

#define TRACE_PARALLEL_IOPORT_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PARALLEL_IOPORT_WRITE) || \
    false)

static inline void _nocheck__trace_parallel_ioport_write(const char * desc, uint16_t addr, uint8_t value)
{
    if (trace_event_get_state(TRACE_PARALLEL_IOPORT_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:parallel_ioport_write " "write [%s] addr 0x%02x val 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , desc, addr, value);
#line 398 "trace/trace-hw_char.h"
        } else {
#line 5 "../hw/char/trace-events"
            qemu_log("parallel_ioport_write " "write [%s] addr 0x%02x val 0x%02x" "\n", desc, addr, value);
#line 402 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_parallel_ioport_write(const char * desc, uint16_t addr, uint8_t value)
{
    if (true) {
        _nocheck__trace_parallel_ioport_write(desc, addr, value);
    }
}

#define TRACE_SERIAL_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SERIAL_READ) || \
    false)

static inline void _nocheck__trace_serial_read(uint16_t addr, uint8_t value)
{
    if (trace_event_get_state(TRACE_SERIAL_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:serial_read " "read addr 0x%02x val 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value);
#line 429 "trace/trace-hw_char.h"
        } else {
#line 8 "../hw/char/trace-events"
            qemu_log("serial_read " "read addr 0x%02x val 0x%02x" "\n", addr, value);
#line 433 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_serial_read(uint16_t addr, uint8_t value)
{
    if (true) {
        _nocheck__trace_serial_read(addr, value);
    }
}

#define TRACE_SERIAL_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SERIAL_WRITE) || \
    false)

static inline void _nocheck__trace_serial_write(uint16_t addr, uint8_t value)
{
    if (trace_event_get_state(TRACE_SERIAL_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:serial_write " "write addr 0x%02x val 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value);
#line 460 "trace/trace-hw_char.h"
        } else {
#line 9 "../hw/char/trace-events"
            qemu_log("serial_write " "write addr 0x%02x val 0x%02x" "\n", addr, value);
#line 464 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_serial_write(uint16_t addr, uint8_t value)
{
    if (true) {
        _nocheck__trace_serial_write(addr, value);
    }
}

#define TRACE_SERIAL_UPDATE_PARAMETERS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SERIAL_UPDATE_PARAMETERS) || \
    false)

static inline void _nocheck__trace_serial_update_parameters(uint64_t baudrate, char parity, int data_bits, int stop_bits)
{
    if (trace_event_get_state(TRACE_SERIAL_UPDATE_PARAMETERS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:serial_update_parameters " "baudrate=%"PRIu64" parity='%c' data=%d stop=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , baudrate, parity, data_bits, stop_bits);
#line 491 "trace/trace-hw_char.h"
        } else {
#line 10 "../hw/char/trace-events"
            qemu_log("serial_update_parameters " "baudrate=%"PRIu64" parity='%c' data=%d stop=%d" "\n", baudrate, parity, data_bits, stop_bits);
#line 495 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_serial_update_parameters(uint64_t baudrate, char parity, int data_bits, int stop_bits)
{
    if (true) {
        _nocheck__trace_serial_update_parameters(baudrate, parity, data_bits, stop_bits);
    }
}

#define TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT) || \
    false)

static inline void _nocheck__trace_virtio_serial_send_control_event(unsigned int port, uint16_t event, uint16_t value)
{
    if (trace_event_get_state(TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_serial_send_control_event " "port %u, event %u, value %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , port, event, value);
#line 522 "trace/trace-hw_char.h"
        } else {
#line 13 "../hw/char/trace-events"
            qemu_log("virtio_serial_send_control_event " "port %u, event %u, value %u" "\n", port, event, value);
#line 526 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_serial_send_control_event(unsigned int port, uint16_t event, uint16_t value)
{
    if (true) {
        _nocheck__trace_virtio_serial_send_control_event(port, event, value);
    }
}

#define TRACE_VIRTIO_SERIAL_THROTTLE_PORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SERIAL_THROTTLE_PORT) || \
    false)

static inline void _nocheck__trace_virtio_serial_throttle_port(unsigned int port, bool throttle)
{
    if (trace_event_get_state(TRACE_VIRTIO_SERIAL_THROTTLE_PORT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_serial_throttle_port " "port %u, throttle %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , port, throttle);
#line 553 "trace/trace-hw_char.h"
        } else {
#line 14 "../hw/char/trace-events"
            qemu_log("virtio_serial_throttle_port " "port %u, throttle %d" "\n", port, throttle);
#line 557 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_serial_throttle_port(unsigned int port, bool throttle)
{
    if (true) {
        _nocheck__trace_virtio_serial_throttle_port(port, throttle);
    }
}

#define TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE) || \
    false)

static inline void _nocheck__trace_virtio_serial_handle_control_message(uint16_t event, uint16_t value)
{
    if (trace_event_get_state(TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_serial_handle_control_message " "event %u, value %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , event, value);
#line 584 "trace/trace-hw_char.h"
        } else {
#line 15 "../hw/char/trace-events"
            qemu_log("virtio_serial_handle_control_message " "event %u, value %u" "\n", event, value);
#line 588 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_serial_handle_control_message(uint16_t event, uint16_t value)
{
    if (true) {
        _nocheck__trace_virtio_serial_handle_control_message(event, value);
    }
}

#define TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT) || \
    false)

static inline void _nocheck__trace_virtio_serial_handle_control_message_port(unsigned int port)
{
    if (trace_event_get_state(TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_serial_handle_control_message_port " "port %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , port);
#line 615 "trace/trace-hw_char.h"
        } else {
#line 16 "../hw/char/trace-events"
            qemu_log("virtio_serial_handle_control_message_port " "port %u" "\n", port);
#line 619 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_serial_handle_control_message_port(unsigned int port)
{
    if (true) {
        _nocheck__trace_virtio_serial_handle_control_message_port(port);
    }
}

#define TRACE_VIRTIO_CONSOLE_FLUSH_BUF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_CONSOLE_FLUSH_BUF) || \
    false)

static inline void _nocheck__trace_virtio_console_flush_buf(unsigned int port, size_t len, ssize_t ret)
{
    if (trace_event_get_state(TRACE_VIRTIO_CONSOLE_FLUSH_BUF) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_console_flush_buf " "port %u, in_len %zu, out_len %zd" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , port, len, ret);
#line 646 "trace/trace-hw_char.h"
        } else {
#line 19 "../hw/char/trace-events"
            qemu_log("virtio_console_flush_buf " "port %u, in_len %zu, out_len %zd" "\n", port, len, ret);
#line 650 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_console_flush_buf(unsigned int port, size_t len, ssize_t ret)
{
    if (true) {
        _nocheck__trace_virtio_console_flush_buf(port, len, ret);
    }
}

#define TRACE_VIRTIO_CONSOLE_CHR_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_CONSOLE_CHR_READ) || \
    false)

static inline void _nocheck__trace_virtio_console_chr_read(unsigned int port, int size)
{
    if (trace_event_get_state(TRACE_VIRTIO_CONSOLE_CHR_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_console_chr_read " "port %u, size %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , port, size);
#line 677 "trace/trace-hw_char.h"
        } else {
#line 20 "../hw/char/trace-events"
            qemu_log("virtio_console_chr_read " "port %u, size %d" "\n", port, size);
#line 681 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_console_chr_read(unsigned int port, int size)
{
    if (true) {
        _nocheck__trace_virtio_console_chr_read(port, size);
    }
}

#define TRACE_VIRTIO_CONSOLE_CHR_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_CONSOLE_CHR_EVENT) || \
    false)

static inline void _nocheck__trace_virtio_console_chr_event(unsigned int port, int event)
{
    if (trace_event_get_state(TRACE_VIRTIO_CONSOLE_CHR_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_console_chr_event " "port %u, event %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , port, event);
#line 708 "trace/trace-hw_char.h"
        } else {
#line 21 "../hw/char/trace-events"
            qemu_log("virtio_console_chr_event " "port %u, event %d" "\n", port, event);
#line 712 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_console_chr_event(unsigned int port, int event)
{
    if (true) {
        _nocheck__trace_virtio_console_chr_event(port, event);
    }
}

#define TRACE_GOLDFISH_TTY_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GOLDFISH_TTY_READ) || \
    false)

static inline void _nocheck__trace_goldfish_tty_read(void * dev, unsigned int addr, unsigned int size, uint64_t value)
{
    if (trace_event_get_state(TRACE_GOLDFISH_TTY_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:goldfish_tty_read " "tty: %p reg: 0x%02x size: %d value: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, addr, size, value);
#line 739 "trace/trace-hw_char.h"
        } else {
#line 24 "../hw/char/trace-events"
            qemu_log("goldfish_tty_read " "tty: %p reg: 0x%02x size: %d value: 0x%"PRIx64 "\n", dev, addr, size, value);
#line 743 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_goldfish_tty_read(void * dev, unsigned int addr, unsigned int size, uint64_t value)
{
    if (true) {
        _nocheck__trace_goldfish_tty_read(dev, addr, size, value);
    }
}

#define TRACE_GOLDFISH_TTY_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GOLDFISH_TTY_WRITE) || \
    false)

static inline void _nocheck__trace_goldfish_tty_write(void * dev, unsigned int addr, unsigned int size, uint64_t value)
{
    if (trace_event_get_state(TRACE_GOLDFISH_TTY_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:goldfish_tty_write " "tty: %p reg: 0x%02x size: %d value: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, addr, size, value);
#line 770 "trace/trace-hw_char.h"
        } else {
#line 25 "../hw/char/trace-events"
            qemu_log("goldfish_tty_write " "tty: %p reg: 0x%02x size: %d value: 0x%"PRIx64 "\n", dev, addr, size, value);
#line 774 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_goldfish_tty_write(void * dev, unsigned int addr, unsigned int size, uint64_t value)
{
    if (true) {
        _nocheck__trace_goldfish_tty_write(dev, addr, size, value);
    }
}

#define TRACE_GOLDFISH_TTY_CAN_RECEIVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GOLDFISH_TTY_CAN_RECEIVE) || \
    false)

static inline void _nocheck__trace_goldfish_tty_can_receive(void * dev, unsigned int available)
{
    if (trace_event_get_state(TRACE_GOLDFISH_TTY_CAN_RECEIVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:goldfish_tty_can_receive " "tty: %p available: %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, available);
#line 801 "trace/trace-hw_char.h"
        } else {
#line 26 "../hw/char/trace-events"
            qemu_log("goldfish_tty_can_receive " "tty: %p available: %u" "\n", dev, available);
#line 805 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_goldfish_tty_can_receive(void * dev, unsigned int available)
{
    if (true) {
        _nocheck__trace_goldfish_tty_can_receive(dev, available);
    }
}

#define TRACE_GOLDFISH_TTY_RECEIVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GOLDFISH_TTY_RECEIVE) || \
    false)

static inline void _nocheck__trace_goldfish_tty_receive(void * dev, unsigned int size)
{
    if (trace_event_get_state(TRACE_GOLDFISH_TTY_RECEIVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:goldfish_tty_receive " "tty: %p size: %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, size);
#line 832 "trace/trace-hw_char.h"
        } else {
#line 27 "../hw/char/trace-events"
            qemu_log("goldfish_tty_receive " "tty: %p size: %u" "\n", dev, size);
#line 836 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_goldfish_tty_receive(void * dev, unsigned int size)
{
    if (true) {
        _nocheck__trace_goldfish_tty_receive(dev, size);
    }
}

#define TRACE_GOLDFISH_TTY_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GOLDFISH_TTY_RESET) || \
    false)

static inline void _nocheck__trace_goldfish_tty_reset(void * dev)
{
    if (trace_event_get_state(TRACE_GOLDFISH_TTY_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:goldfish_tty_reset " "tty: %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev);
#line 863 "trace/trace-hw_char.h"
        } else {
#line 28 "../hw/char/trace-events"
            qemu_log("goldfish_tty_reset " "tty: %p" "\n", dev);
#line 867 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_goldfish_tty_reset(void * dev)
{
    if (true) {
        _nocheck__trace_goldfish_tty_reset(dev);
    }
}

#define TRACE_GOLDFISH_TTY_REALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GOLDFISH_TTY_REALIZE) || \
    false)

static inline void _nocheck__trace_goldfish_tty_realize(void * dev)
{
    if (trace_event_get_state(TRACE_GOLDFISH_TTY_REALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:goldfish_tty_realize " "tty: %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev);
#line 894 "trace/trace-hw_char.h"
        } else {
#line 29 "../hw/char/trace-events"
            qemu_log("goldfish_tty_realize " "tty: %p" "\n", dev);
#line 898 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_goldfish_tty_realize(void * dev)
{
    if (true) {
        _nocheck__trace_goldfish_tty_realize(dev);
    }
}

#define TRACE_GOLDFISH_TTY_UNREALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GOLDFISH_TTY_UNREALIZE) || \
    false)

static inline void _nocheck__trace_goldfish_tty_unrealize(void * dev)
{
    if (trace_event_get_state(TRACE_GOLDFISH_TTY_UNREALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:goldfish_tty_unrealize " "tty: %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev);
#line 925 "trace/trace-hw_char.h"
        } else {
#line 30 "../hw/char/trace-events"
            qemu_log("goldfish_tty_unrealize " "tty: %p" "\n", dev);
#line 929 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_goldfish_tty_unrealize(void * dev)
{
    if (true) {
        _nocheck__trace_goldfish_tty_unrealize(dev);
    }
}

#define TRACE_GOLDFISH_TTY_INSTANCE_INIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GOLDFISH_TTY_INSTANCE_INIT) || \
    false)

static inline void _nocheck__trace_goldfish_tty_instance_init(void * dev)
{
    if (trace_event_get_state(TRACE_GOLDFISH_TTY_INSTANCE_INIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:goldfish_tty_instance_init " "tty: %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev);
#line 956 "trace/trace-hw_char.h"
        } else {
#line 31 "../hw/char/trace-events"
            qemu_log("goldfish_tty_instance_init " "tty: %p" "\n", dev);
#line 960 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_goldfish_tty_instance_init(void * dev)
{
    if (true) {
        _nocheck__trace_goldfish_tty_instance_init(dev);
    }
}

#define TRACE_GRLIB_APBUART_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_APBUART_EVENT) || \
    false)

static inline void _nocheck__trace_grlib_apbuart_event(int event)
{
    if (trace_event_get_state(TRACE_GRLIB_APBUART_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:grlib_apbuart_event " "event:%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , event);
#line 987 "trace/trace-hw_char.h"
        } else {
#line 34 "../hw/char/trace-events"
            qemu_log("grlib_apbuart_event " "event:%d" "\n", event);
#line 991 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_grlib_apbuart_event(int event)
{
    if (true) {
        _nocheck__trace_grlib_apbuart_event(event);
    }
}

#define TRACE_GRLIB_APBUART_WRITEL_UNKNOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_APBUART_WRITEL_UNKNOWN) || \
    false)

static inline void _nocheck__trace_grlib_apbuart_writel_unknown(uint64_t addr, uint32_t value)
{
    if (trace_event_get_state(TRACE_GRLIB_APBUART_WRITEL_UNKNOWN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 35 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:grlib_apbuart_writel_unknown " "addr 0x%"PRIx64" value 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value);
#line 1018 "trace/trace-hw_char.h"
        } else {
#line 35 "../hw/char/trace-events"
            qemu_log("grlib_apbuart_writel_unknown " "addr 0x%"PRIx64" value 0x%x" "\n", addr, value);
#line 1022 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_grlib_apbuart_writel_unknown(uint64_t addr, uint32_t value)
{
    if (true) {
        _nocheck__trace_grlib_apbuart_writel_unknown(addr, value);
    }
}

#define TRACE_GRLIB_APBUART_READL_UNKNOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_APBUART_READL_UNKNOWN) || \
    false)

static inline void _nocheck__trace_grlib_apbuart_readl_unknown(uint64_t addr)
{
    if (trace_event_get_state(TRACE_GRLIB_APBUART_READL_UNKNOWN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 36 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:grlib_apbuart_readl_unknown " "addr 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 1049 "trace/trace-hw_char.h"
        } else {
#line 36 "../hw/char/trace-events"
            qemu_log("grlib_apbuart_readl_unknown " "addr 0x%"PRIx64 "\n", addr);
#line 1053 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_grlib_apbuart_readl_unknown(uint64_t addr)
{
    if (true) {
        _nocheck__trace_grlib_apbuart_readl_unknown(addr);
    }
}

#define TRACE_ESCC_HARD_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_HARD_RESET) || \
    false)

static inline void _nocheck__trace_escc_hard_reset(void)
{
    if (trace_event_get_state(TRACE_ESCC_HARD_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 39 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_hard_reset " "hard reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1080 "trace/trace-hw_char.h"
        } else {
#line 39 "../hw/char/trace-events"
            qemu_log("escc_hard_reset " "hard reset" "\n");
#line 1084 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_hard_reset(void)
{
    if (true) {
        _nocheck__trace_escc_hard_reset();
    }
}

#define TRACE_ESCC_SOFT_RESET_CHN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_SOFT_RESET_CHN) || \
    false)

static inline void _nocheck__trace_escc_soft_reset_chn(char channel)
{
    if (trace_event_get_state(TRACE_ESCC_SOFT_RESET_CHN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 40 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_soft_reset_chn " "soft reset channel %c" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 1111 "trace/trace-hw_char.h"
        } else {
#line 40 "../hw/char/trace-events"
            qemu_log("escc_soft_reset_chn " "soft reset channel %c" "\n", channel);
#line 1115 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_soft_reset_chn(char channel)
{
    if (true) {
        _nocheck__trace_escc_soft_reset_chn(channel);
    }
}

#define TRACE_ESCC_PUT_QUEUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_PUT_QUEUE) || \
    false)

static inline void _nocheck__trace_escc_put_queue(char channel, int b)
{
    if (trace_event_get_state(TRACE_ESCC_PUT_QUEUE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 41 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_put_queue " "channel %c put: 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, b);
#line 1142 "trace/trace-hw_char.h"
        } else {
#line 41 "../hw/char/trace-events"
            qemu_log("escc_put_queue " "channel %c put: 0x%02x" "\n", channel, b);
#line 1146 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_put_queue(char channel, int b)
{
    if (true) {
        _nocheck__trace_escc_put_queue(channel, b);
    }
}

#define TRACE_ESCC_GET_QUEUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_GET_QUEUE) || \
    false)

static inline void _nocheck__trace_escc_get_queue(char channel, int val)
{
    if (trace_event_get_state(TRACE_ESCC_GET_QUEUE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 42 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_get_queue " "channel %c get 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, val);
#line 1173 "trace/trace-hw_char.h"
        } else {
#line 42 "../hw/char/trace-events"
            qemu_log("escc_get_queue " "channel %c get 0x%02x" "\n", channel, val);
#line 1177 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_get_queue(char channel, int val)
{
    if (true) {
        _nocheck__trace_escc_get_queue(channel, val);
    }
}

#define TRACE_ESCC_UPDATE_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_UPDATE_IRQ) || \
    false)

static inline void _nocheck__trace_escc_update_irq(int irq)
{
    if (trace_event_get_state(TRACE_ESCC_UPDATE_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 43 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_update_irq " "IRQ = %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , irq);
#line 1204 "trace/trace-hw_char.h"
        } else {
#line 43 "../hw/char/trace-events"
            qemu_log("escc_update_irq " "IRQ = %d" "\n", irq);
#line 1208 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_update_irq(int irq)
{
    if (true) {
        _nocheck__trace_escc_update_irq(irq);
    }
}

#define TRACE_ESCC_UPDATE_PARAMETERS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_UPDATE_PARAMETERS) || \
    false)

static inline void _nocheck__trace_escc_update_parameters(char channel, int speed, int parity, int data_bits, int stop_bits)
{
    if (trace_event_get_state(TRACE_ESCC_UPDATE_PARAMETERS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 44 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_update_parameters " "channel %c: speed=%d parity=%c data=%d stop=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, speed, parity, data_bits, stop_bits);
#line 1235 "trace/trace-hw_char.h"
        } else {
#line 44 "../hw/char/trace-events"
            qemu_log("escc_update_parameters " "channel %c: speed=%d parity=%c data=%d stop=%d" "\n", channel, speed, parity, data_bits, stop_bits);
#line 1239 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_update_parameters(char channel, int speed, int parity, int data_bits, int stop_bits)
{
    if (true) {
        _nocheck__trace_escc_update_parameters(channel, speed, parity, data_bits, stop_bits);
    }
}

#define TRACE_ESCC_MEM_WRITEB_CTRL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_MEM_WRITEB_CTRL) || \
    false)

static inline void _nocheck__trace_escc_mem_writeb_ctrl(char channel, uint32_t reg, uint32_t val)
{
    if (trace_event_get_state(TRACE_ESCC_MEM_WRITEB_CTRL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 45 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_mem_writeb_ctrl " "Write channel %c, reg[%d] = 0x%2.2x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, reg, val);
#line 1266 "trace/trace-hw_char.h"
        } else {
#line 45 "../hw/char/trace-events"
            qemu_log("escc_mem_writeb_ctrl " "Write channel %c, reg[%d] = 0x%2.2x" "\n", channel, reg, val);
#line 1270 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_mem_writeb_ctrl(char channel, uint32_t reg, uint32_t val)
{
    if (true) {
        _nocheck__trace_escc_mem_writeb_ctrl(channel, reg, val);
    }
}

#define TRACE_ESCC_MEM_WRITEB_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_MEM_WRITEB_DATA) || \
    false)

static inline void _nocheck__trace_escc_mem_writeb_data(char channel, uint32_t val)
{
    if (trace_event_get_state(TRACE_ESCC_MEM_WRITEB_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_mem_writeb_data " "Write channel %c, ch %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, val);
#line 1297 "trace/trace-hw_char.h"
        } else {
#line 46 "../hw/char/trace-events"
            qemu_log("escc_mem_writeb_data " "Write channel %c, ch %d" "\n", channel, val);
#line 1301 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_mem_writeb_data(char channel, uint32_t val)
{
    if (true) {
        _nocheck__trace_escc_mem_writeb_data(channel, val);
    }
}

#define TRACE_ESCC_MEM_READB_CTRL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_MEM_READB_CTRL) || \
    false)

static inline void _nocheck__trace_escc_mem_readb_ctrl(char channel, uint32_t reg, uint8_t val)
{
    if (trace_event_get_state(TRACE_ESCC_MEM_READB_CTRL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 47 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_mem_readb_ctrl " "Read channel %c, reg[%d] = 0x%2.2x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, reg, val);
#line 1328 "trace/trace-hw_char.h"
        } else {
#line 47 "../hw/char/trace-events"
            qemu_log("escc_mem_readb_ctrl " "Read channel %c, reg[%d] = 0x%2.2x" "\n", channel, reg, val);
#line 1332 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_mem_readb_ctrl(char channel, uint32_t reg, uint8_t val)
{
    if (true) {
        _nocheck__trace_escc_mem_readb_ctrl(channel, reg, val);
    }
}

#define TRACE_ESCC_MEM_READB_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_MEM_READB_DATA) || \
    false)

static inline void _nocheck__trace_escc_mem_readb_data(char channel, uint32_t ret)
{
    if (trace_event_get_state(TRACE_ESCC_MEM_READB_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 48 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_mem_readb_data " "Read channel %c, ch %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, ret);
#line 1359 "trace/trace-hw_char.h"
        } else {
#line 48 "../hw/char/trace-events"
            qemu_log("escc_mem_readb_data " "Read channel %c, ch %d" "\n", channel, ret);
#line 1363 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_mem_readb_data(char channel, uint32_t ret)
{
    if (true) {
        _nocheck__trace_escc_mem_readb_data(channel, ret);
    }
}

#define TRACE_ESCC_SERIAL_RECEIVE_BYTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_SERIAL_RECEIVE_BYTE) || \
    false)

static inline void _nocheck__trace_escc_serial_receive_byte(char channel, int ch)
{
    if (trace_event_get_state(TRACE_ESCC_SERIAL_RECEIVE_BYTE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 49 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_serial_receive_byte " "channel %c put ch %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, ch);
#line 1390 "trace/trace-hw_char.h"
        } else {
#line 49 "../hw/char/trace-events"
            qemu_log("escc_serial_receive_byte " "channel %c put ch %d" "\n", channel, ch);
#line 1394 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_serial_receive_byte(char channel, int ch)
{
    if (true) {
        _nocheck__trace_escc_serial_receive_byte(channel, ch);
    }
}

#define TRACE_ESCC_SUNKBD_EVENT_IN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_SUNKBD_EVENT_IN) || \
    false)

static inline void _nocheck__trace_escc_sunkbd_event_in(int ch, const char * name, int down)
{
    if (trace_event_get_state(TRACE_ESCC_SUNKBD_EVENT_IN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 50 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_sunkbd_event_in " "QKeyCode 0x%2.2x [%s], down %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ch, name, down);
#line 1421 "trace/trace-hw_char.h"
        } else {
#line 50 "../hw/char/trace-events"
            qemu_log("escc_sunkbd_event_in " "QKeyCode 0x%2.2x [%s], down %d" "\n", ch, name, down);
#line 1425 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_sunkbd_event_in(int ch, const char * name, int down)
{
    if (true) {
        _nocheck__trace_escc_sunkbd_event_in(ch, name, down);
    }
}

#define TRACE_ESCC_SUNKBD_EVENT_OUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_SUNKBD_EVENT_OUT) || \
    false)

static inline void _nocheck__trace_escc_sunkbd_event_out(int ch)
{
    if (trace_event_get_state(TRACE_ESCC_SUNKBD_EVENT_OUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 51 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_sunkbd_event_out " "Translated keycode 0x%2.2x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ch);
#line 1452 "trace/trace-hw_char.h"
        } else {
#line 51 "../hw/char/trace-events"
            qemu_log("escc_sunkbd_event_out " "Translated keycode 0x%2.2x" "\n", ch);
#line 1456 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_sunkbd_event_out(int ch)
{
    if (true) {
        _nocheck__trace_escc_sunkbd_event_out(ch);
    }
}

#define TRACE_ESCC_KBD_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_KBD_COMMAND) || \
    false)

static inline void _nocheck__trace_escc_kbd_command(int val)
{
    if (trace_event_get_state(TRACE_ESCC_KBD_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 52 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_kbd_command " "Command %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 1483 "trace/trace-hw_char.h"
        } else {
#line 52 "../hw/char/trace-events"
            qemu_log("escc_kbd_command " "Command %d" "\n", val);
#line 1487 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_kbd_command(int val)
{
    if (true) {
        _nocheck__trace_escc_kbd_command(val);
    }
}

#define TRACE_ESCC_SUNMOUSE_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_SUNMOUSE_EVENT) || \
    false)

static inline void _nocheck__trace_escc_sunmouse_event(int dx, int dy, int buttons_state)
{
    if (trace_event_get_state(TRACE_ESCC_SUNMOUSE_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_sunmouse_event " "dx=%d dy=%d buttons=0x%01x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dx, dy, buttons_state);
#line 1514 "trace/trace-hw_char.h"
        } else {
#line 53 "../hw/char/trace-events"
            qemu_log("escc_sunmouse_event " "dx=%d dy=%d buttons=0x%01x" "\n", dx, dy, buttons_state);
#line 1518 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_sunmouse_event(int dx, int dy, int buttons_state)
{
    if (true) {
        _nocheck__trace_escc_sunmouse_event(dx, dy, buttons_state);
    }
}

#define TRACE_IMX_SERIAL_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IMX_SERIAL_READ) || \
    false)

static inline void _nocheck__trace_imx_serial_read(const char * chrname, uint64_t addr, uint64_t value)
{
    if (trace_event_get_state(TRACE_IMX_SERIAL_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 56 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:imx_serial_read " "%s:[0x%03" PRIu64 "] -> 0x%08" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , chrname, addr, value);
#line 1545 "trace/trace-hw_char.h"
        } else {
#line 56 "../hw/char/trace-events"
            qemu_log("imx_serial_read " "%s:[0x%03" PRIu64 "] -> 0x%08" PRIx64 "\n", chrname, addr, value);
#line 1549 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_imx_serial_read(const char * chrname, uint64_t addr, uint64_t value)
{
    if (true) {
        _nocheck__trace_imx_serial_read(chrname, addr, value);
    }
}

#define TRACE_IMX_SERIAL_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IMX_SERIAL_WRITE) || \
    false)

static inline void _nocheck__trace_imx_serial_write(const char * chrname, uint64_t addr, uint64_t value)
{
    if (trace_event_get_state(TRACE_IMX_SERIAL_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 57 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:imx_serial_write " "%s:[0x%03" PRIu64 "] <- 0x%08" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , chrname, addr, value);
#line 1576 "trace/trace-hw_char.h"
        } else {
#line 57 "../hw/char/trace-events"
            qemu_log("imx_serial_write " "%s:[0x%03" PRIu64 "] <- 0x%08" PRIx64 "\n", chrname, addr, value);
#line 1580 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_imx_serial_write(const char * chrname, uint64_t addr, uint64_t value)
{
    if (true) {
        _nocheck__trace_imx_serial_write(chrname, addr, value);
    }
}

#define TRACE_IMX_SERIAL_PUT_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IMX_SERIAL_PUT_DATA) || \
    false)

static inline void _nocheck__trace_imx_serial_put_data(const char * chrname, uint32_t value)
{
    if (trace_event_get_state(TRACE_IMX_SERIAL_PUT_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 58 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:imx_serial_put_data " "%s: 0x%" PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , chrname, value);
#line 1607 "trace/trace-hw_char.h"
        } else {
#line 58 "../hw/char/trace-events"
            qemu_log("imx_serial_put_data " "%s: 0x%" PRIx32 "\n", chrname, value);
#line 1611 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_imx_serial_put_data(const char * chrname, uint32_t value)
{
    if (true) {
        _nocheck__trace_imx_serial_put_data(chrname, value);
    }
}

#define TRACE_PL011_IRQ_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_IRQ_STATE) || \
    false)

static inline void _nocheck__trace_pl011_irq_state(int level)
{
    if (trace_event_get_state(TRACE_PL011_IRQ_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 61 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_irq_state " "irq state %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , level);
#line 1638 "trace/trace-hw_char.h"
        } else {
#line 61 "../hw/char/trace-events"
            qemu_log("pl011_irq_state " "irq state %d" "\n", level);
#line 1642 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_irq_state(int level)
{
    if (true) {
        _nocheck__trace_pl011_irq_state(level);
    }
}

#define TRACE_PL011_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_READ) || \
    false)

static inline void _nocheck__trace_pl011_read(uint32_t addr, uint32_t value, const char * regname)
{
    if (trace_event_get_state(TRACE_PL011_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 62 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_read " "addr 0x%03x value 0x%08x reg %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value, regname);
#line 1669 "trace/trace-hw_char.h"
        } else {
#line 62 "../hw/char/trace-events"
            qemu_log("pl011_read " "addr 0x%03x value 0x%08x reg %s" "\n", addr, value, regname);
#line 1673 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_read(uint32_t addr, uint32_t value, const char * regname)
{
    if (true) {
        _nocheck__trace_pl011_read(addr, value, regname);
    }
}

#define TRACE_PL011_READ_FIFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_READ_FIFO) || \
    false)

static inline void _nocheck__trace_pl011_read_fifo(unsigned rx_fifo_used, size_t rx_fifo_depth)
{
    if (trace_event_get_state(TRACE_PL011_READ_FIFO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 63 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_read_fifo " "RX FIFO read, used %u/%zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , rx_fifo_used, rx_fifo_depth);
#line 1700 "trace/trace-hw_char.h"
        } else {
#line 63 "../hw/char/trace-events"
            qemu_log("pl011_read_fifo " "RX FIFO read, used %u/%zu" "\n", rx_fifo_used, rx_fifo_depth);
#line 1704 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_read_fifo(unsigned rx_fifo_used, size_t rx_fifo_depth)
{
    if (true) {
        _nocheck__trace_pl011_read_fifo(rx_fifo_used, rx_fifo_depth);
    }
}

#define TRACE_PL011_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_WRITE) || \
    false)

static inline void _nocheck__trace_pl011_write(uint32_t addr, uint32_t value, const char * regname)
{
    if (trace_event_get_state(TRACE_PL011_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 64 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_write " "addr 0x%03x value 0x%08x reg %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value, regname);
#line 1731 "trace/trace-hw_char.h"
        } else {
#line 64 "../hw/char/trace-events"
            qemu_log("pl011_write " "addr 0x%03x value 0x%08x reg %s" "\n", addr, value, regname);
#line 1735 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_write(uint32_t addr, uint32_t value, const char * regname)
{
    if (true) {
        _nocheck__trace_pl011_write(addr, value, regname);
    }
}

#define TRACE_PL011_CAN_RECEIVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_CAN_RECEIVE) || \
    false)

static inline void _nocheck__trace_pl011_can_receive(uint32_t lcr, unsigned rx_fifo_used, size_t rx_fifo_depth, unsigned rx_fifo_available)
{
    if (trace_event_get_state(TRACE_PL011_CAN_RECEIVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 65 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_can_receive " "LCR 0x%02x, RX FIFO used %u/%zu, can_receive %u chars" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lcr, rx_fifo_used, rx_fifo_depth, rx_fifo_available);
#line 1762 "trace/trace-hw_char.h"
        } else {
#line 65 "../hw/char/trace-events"
            qemu_log("pl011_can_receive " "LCR 0x%02x, RX FIFO used %u/%zu, can_receive %u chars" "\n", lcr, rx_fifo_used, rx_fifo_depth, rx_fifo_available);
#line 1766 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_can_receive(uint32_t lcr, unsigned rx_fifo_used, size_t rx_fifo_depth, unsigned rx_fifo_available)
{
    if (true) {
        _nocheck__trace_pl011_can_receive(lcr, rx_fifo_used, rx_fifo_depth, rx_fifo_available);
    }
}

#define TRACE_PL011_FIFO_RX_PUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_FIFO_RX_PUT) || \
    false)

static inline void _nocheck__trace_pl011_fifo_rx_put(uint32_t c, unsigned read_count, size_t rx_fifo_depth)
{
    if (trace_event_get_state(TRACE_PL011_FIFO_RX_PUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 66 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_fifo_rx_put " "RX FIFO push char [0x%02x] %d/%zu depth used" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , c, read_count, rx_fifo_depth);
#line 1793 "trace/trace-hw_char.h"
        } else {
#line 66 "../hw/char/trace-events"
            qemu_log("pl011_fifo_rx_put " "RX FIFO push char [0x%02x] %d/%zu depth used" "\n", c, read_count, rx_fifo_depth);
#line 1797 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_fifo_rx_put(uint32_t c, unsigned read_count, size_t rx_fifo_depth)
{
    if (true) {
        _nocheck__trace_pl011_fifo_rx_put(c, read_count, rx_fifo_depth);
    }
}

#define TRACE_PL011_FIFO_RX_FULL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_FIFO_RX_FULL) || \
    false)

static inline void _nocheck__trace_pl011_fifo_rx_full(void)
{
    if (trace_event_get_state(TRACE_PL011_FIFO_RX_FULL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 67 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_fifo_rx_full " "RX FIFO now full, RXFF set" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1824 "trace/trace-hw_char.h"
        } else {
#line 67 "../hw/char/trace-events"
            qemu_log("pl011_fifo_rx_full " "RX FIFO now full, RXFF set" "\n");
#line 1828 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_fifo_rx_full(void)
{
    if (true) {
        _nocheck__trace_pl011_fifo_rx_full();
    }
}

#define TRACE_PL011_BAUDRATE_CHANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_BAUDRATE_CHANGE) || \
    false)

static inline void _nocheck__trace_pl011_baudrate_change(unsigned int baudrate, uint64_t clock, uint32_t ibrd, uint32_t fbrd)
{
    if (trace_event_get_state(TRACE_PL011_BAUDRATE_CHANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 68 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_baudrate_change " "new baudrate %u (clk: %" PRIu64 "hz, ibrd: %" PRIu32 ", fbrd: %" PRIu32 ")" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , baudrate, clock, ibrd, fbrd);
#line 1855 "trace/trace-hw_char.h"
        } else {
#line 68 "../hw/char/trace-events"
            qemu_log("pl011_baudrate_change " "new baudrate %u (clk: %" PRIu64 "hz, ibrd: %" PRIu32 ", fbrd: %" PRIu32 ")" "\n", baudrate, clock, ibrd, fbrd);
#line 1859 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_baudrate_change(unsigned int baudrate, uint64_t clock, uint32_t ibrd, uint32_t fbrd)
{
    if (true) {
        _nocheck__trace_pl011_baudrate_change(baudrate, clock, ibrd, fbrd);
    }
}

#define TRACE_PL011_RECEIVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_RECEIVE) || \
    false)

static inline void _nocheck__trace_pl011_receive(int size)
{
    if (trace_event_get_state(TRACE_PL011_RECEIVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 69 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_receive " "recv %d chars" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , size);
#line 1886 "trace/trace-hw_char.h"
        } else {
#line 69 "../hw/char/trace-events"
            qemu_log("pl011_receive " "recv %d chars" "\n", size);
#line 1890 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_receive(int size)
{
    if (true) {
        _nocheck__trace_pl011_receive(size);
    }
}

#define TRACE_NXP_UART_IRQ_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NXP_UART_IRQ_STATE) || \
    false)

static inline void _nocheck__trace_nxp_uart_irq_state(int level)
{
    if (trace_event_get_state(TRACE_NXP_UART_IRQ_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 72 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:nxp_uart_irq_state " "irq state %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , level);
#line 1917 "trace/trace-hw_char.h"
        } else {
#line 72 "../hw/char/trace-events"
            qemu_log("nxp_uart_irq_state " "irq state %d" "\n", level);
#line 1921 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_nxp_uart_irq_state(int level)
{
    if (true) {
        _nocheck__trace_nxp_uart_irq_state(level);
    }
}

#define TRACE_NXP_UART_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NXP_UART_READ) || \
    false)

static inline void _nocheck__trace_nxp_uart_read(uint32_t addr, uint32_t value, const char * regname)
{
    if (trace_event_get_state(TRACE_NXP_UART_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 73 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:nxp_uart_read " "addr 0x%03x value 0x%08x reg %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value, regname);
#line 1948 "trace/trace-hw_char.h"
        } else {
#line 73 "../hw/char/trace-events"
            qemu_log("nxp_uart_read " "addr 0x%03x value 0x%08x reg %s" "\n", addr, value, regname);
#line 1952 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_nxp_uart_read(uint32_t addr, uint32_t value, const char * regname)
{
    if (true) {
        _nocheck__trace_nxp_uart_read(addr, value, regname);
    }
}

#define TRACE_NXP_UART_READ_FIFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NXP_UART_READ_FIFO) || \
    false)

static inline void _nocheck__trace_nxp_uart_read_fifo(unsigned rx_fifo_used, size_t rx_fifo_depth)
{
    if (trace_event_get_state(TRACE_NXP_UART_READ_FIFO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 74 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:nxp_uart_read_fifo " "RX FIFO read, used %u/%zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , rx_fifo_used, rx_fifo_depth);
#line 1979 "trace/trace-hw_char.h"
        } else {
#line 74 "../hw/char/trace-events"
            qemu_log("nxp_uart_read_fifo " "RX FIFO read, used %u/%zu" "\n", rx_fifo_used, rx_fifo_depth);
#line 1983 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_nxp_uart_read_fifo(unsigned rx_fifo_used, size_t rx_fifo_depth)
{
    if (true) {
        _nocheck__trace_nxp_uart_read_fifo(rx_fifo_used, rx_fifo_depth);
    }
}

#define TRACE_NXP_UART_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NXP_UART_WRITE) || \
    false)

static inline void _nocheck__trace_nxp_uart_write(uint32_t addr, uint32_t value, const char * regname)
{
    if (trace_event_get_state(TRACE_NXP_UART_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 75 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:nxp_uart_write " "addr 0x%03x value 0x%08x reg %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value, regname);
#line 2010 "trace/trace-hw_char.h"
        } else {
#line 75 "../hw/char/trace-events"
            qemu_log("nxp_uart_write " "addr 0x%03x value 0x%08x reg %s" "\n", addr, value, regname);
#line 2014 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_nxp_uart_write(uint32_t addr, uint32_t value, const char * regname)
{
    if (true) {
        _nocheck__trace_nxp_uart_write(addr, value, regname);
    }
}

#define TRACE_NXP_UART_CAN_RECEIVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NXP_UART_CAN_RECEIVE) || \
    false)

static inline void _nocheck__trace_nxp_uart_can_receive(uint32_t lcr, unsigned rx_fifo_used, size_t rx_fifo_depth, unsigned rx_fifo_available)
{
    if (trace_event_get_state(TRACE_NXP_UART_CAN_RECEIVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 76 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:nxp_uart_can_receive " "LCR 0x%02x, RX FIFO used %u/%zu, can_receive %u chars" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lcr, rx_fifo_used, rx_fifo_depth, rx_fifo_available);
#line 2041 "trace/trace-hw_char.h"
        } else {
#line 76 "../hw/char/trace-events"
            qemu_log("nxp_uart_can_receive " "LCR 0x%02x, RX FIFO used %u/%zu, can_receive %u chars" "\n", lcr, rx_fifo_used, rx_fifo_depth, rx_fifo_available);
#line 2045 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_nxp_uart_can_receive(uint32_t lcr, unsigned rx_fifo_used, size_t rx_fifo_depth, unsigned rx_fifo_available)
{
    if (true) {
        _nocheck__trace_nxp_uart_can_receive(lcr, rx_fifo_used, rx_fifo_depth, rx_fifo_available);
    }
}

#define TRACE_NXP_UART_FIFO_RX_PUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NXP_UART_FIFO_RX_PUT) || \
    false)

static inline void _nocheck__trace_nxp_uart_fifo_rx_put(uint32_t c, unsigned read_count, size_t rx_fifo_depth)
{
    if (trace_event_get_state(TRACE_NXP_UART_FIFO_RX_PUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 77 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:nxp_uart_fifo_rx_put " "RX FIFO push char [0x%02x] %d/%zu depth used" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , c, read_count, rx_fifo_depth);
#line 2072 "trace/trace-hw_char.h"
        } else {
#line 77 "../hw/char/trace-events"
            qemu_log("nxp_uart_fifo_rx_put " "RX FIFO push char [0x%02x] %d/%zu depth used" "\n", c, read_count, rx_fifo_depth);
#line 2076 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_nxp_uart_fifo_rx_put(uint32_t c, unsigned read_count, size_t rx_fifo_depth)
{
    if (true) {
        _nocheck__trace_nxp_uart_fifo_rx_put(c, read_count, rx_fifo_depth);
    }
}

#define TRACE_NXP_UART_FIFO_RX_FULL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NXP_UART_FIFO_RX_FULL) || \
    false)

static inline void _nocheck__trace_nxp_uart_fifo_rx_full(void)
{
    if (trace_event_get_state(TRACE_NXP_UART_FIFO_RX_FULL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 78 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:nxp_uart_fifo_rx_full " "RX FIFO now full, RXFF set" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2103 "trace/trace-hw_char.h"
        } else {
#line 78 "../hw/char/trace-events"
            qemu_log("nxp_uart_fifo_rx_full " "RX FIFO now full, RXFF set" "\n");
#line 2107 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_nxp_uart_fifo_rx_full(void)
{
    if (true) {
        _nocheck__trace_nxp_uart_fifo_rx_full();
    }
}

#define TRACE_NXP_UART_BAUDRATE_CHANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NXP_UART_BAUDRATE_CHANGE) || \
    false)

static inline void _nocheck__trace_nxp_uart_baudrate_change(unsigned int baudrate, uint64_t clock, uint32_t ibrd, uint32_t fbrd)
{
    if (trace_event_get_state(TRACE_NXP_UART_BAUDRATE_CHANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 79 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:nxp_uart_baudrate_change " "new baudrate %u (clk: %" PRIu64 "hz, ibrd: %" PRIu32 ", fbrd: %" PRIu32 ")" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , baudrate, clock, ibrd, fbrd);
#line 2134 "trace/trace-hw_char.h"
        } else {
#line 79 "../hw/char/trace-events"
            qemu_log("nxp_uart_baudrate_change " "new baudrate %u (clk: %" PRIu64 "hz, ibrd: %" PRIu32 ", fbrd: %" PRIu32 ")" "\n", baudrate, clock, ibrd, fbrd);
#line 2138 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_nxp_uart_baudrate_change(unsigned int baudrate, uint64_t clock, uint32_t ibrd, uint32_t fbrd)
{
    if (true) {
        _nocheck__trace_nxp_uart_baudrate_change(baudrate, clock, ibrd, fbrd);
    }
}

#define TRACE_NXP_UART_RECEIVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NXP_UART_RECEIVE) || \
    false)

static inline void _nocheck__trace_nxp_uart_receive(int size)
{
    if (trace_event_get_state(TRACE_NXP_UART_RECEIVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 80 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:nxp_uart_receive " "recv %d chars" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , size);
#line 2165 "trace/trace-hw_char.h"
        } else {
#line 80 "../hw/char/trace-events"
            qemu_log("nxp_uart_receive " "recv %d chars" "\n", size);
#line 2169 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_nxp_uart_receive(int size)
{
    if (true) {
        _nocheck__trace_nxp_uart_receive(size);
    }
}

#define TRACE_CMSDK_APB_UART_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_READ) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_read(uint64_t offset, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 83 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_read " "CMSDK APB UART read: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, data, size);
#line 2196 "trace/trace-hw_char.h"
        } else {
#line 83 "../hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_read " "CMSDK APB UART read: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n", offset, data, size);
#line 2200 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_read(uint64_t offset, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_read(offset, data, size);
    }
}

#define TRACE_CMSDK_APB_UART_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_WRITE) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_write(uint64_t offset, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 84 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_write " "CMSDK APB UART write: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, data, size);
#line 2227 "trace/trace-hw_char.h"
        } else {
#line 84 "../hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_write " "CMSDK APB UART write: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n", offset, data, size);
#line 2231 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_write(uint64_t offset, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_write(offset, data, size);
    }
}

#define TRACE_CMSDK_APB_UART_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_RESET) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_reset(void)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 85 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_reset " "CMSDK APB UART: reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2258 "trace/trace-hw_char.h"
        } else {
#line 85 "../hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_reset " "CMSDK APB UART: reset" "\n");
#line 2262 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_reset(void)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_reset();
    }
}

#define TRACE_CMSDK_APB_UART_RECEIVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_RECEIVE) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_receive(uint8_t c)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_RECEIVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 86 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_receive " "CMSDK APB UART: got character 0x%x from backend" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , c);
#line 2289 "trace/trace-hw_char.h"
        } else {
#line 86 "../hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_receive " "CMSDK APB UART: got character 0x%x from backend" "\n", c);
#line 2293 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_receive(uint8_t c)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_receive(c);
    }
}

#define TRACE_CMSDK_APB_UART_TX_PENDING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_TX_PENDING) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_tx_pending(void)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_TX_PENDING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 87 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_tx_pending " "CMSDK APB UART: character send to backend pending" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2320 "trace/trace-hw_char.h"
        } else {
#line 87 "../hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_tx_pending " "CMSDK APB UART: character send to backend pending" "\n");
#line 2324 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_tx_pending(void)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_tx_pending();
    }
}

#define TRACE_CMSDK_APB_UART_TX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_TX) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_tx(uint8_t c)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_TX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 88 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_tx " "CMSDK APB UART: character 0x%x sent to backend" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , c);
#line 2351 "trace/trace-hw_char.h"
        } else {
#line 88 "../hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_tx " "CMSDK APB UART: character 0x%x sent to backend" "\n", c);
#line 2355 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_tx(uint8_t c)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_tx(c);
    }
}

#define TRACE_CMSDK_APB_UART_SET_PARAMS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_SET_PARAMS) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_set_params(int speed)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_SET_PARAMS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 89 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_set_params " "CMSDK APB UART: params set to %d 8N1" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , speed);
#line 2382 "trace/trace-hw_char.h"
        } else {
#line 89 "../hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_set_params " "CMSDK APB UART: params set to %d 8N1" "\n", speed);
#line 2386 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_set_params(int speed)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_set_params(speed);
    }
}

#define TRACE_NRF51_UART_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NRF51_UART_READ) || \
    false)

static inline void _nocheck__trace_nrf51_uart_read(uint64_t addr, uint64_t r, unsigned int size)
{
    if (trace_event_get_state(TRACE_NRF51_UART_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 92 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:nrf51_uart_read " "addr 0x%" PRIx64 " value 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, r, size);
#line 2413 "trace/trace-hw_char.h"
        } else {
#line 92 "../hw/char/trace-events"
            qemu_log("nrf51_uart_read " "addr 0x%" PRIx64 " value 0x%" PRIx64 " size %u" "\n", addr, r, size);
#line 2417 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_nrf51_uart_read(uint64_t addr, uint64_t r, unsigned int size)
{
    if (true) {
        _nocheck__trace_nrf51_uart_read(addr, r, size);
    }
}

#define TRACE_NRF51_UART_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NRF51_UART_WRITE) || \
    false)

static inline void _nocheck__trace_nrf51_uart_write(uint64_t addr, uint64_t value, unsigned int size)
{
    if (trace_event_get_state(TRACE_NRF51_UART_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 93 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:nrf51_uart_write " "addr 0x%" PRIx64 " value 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value, size);
#line 2444 "trace/trace-hw_char.h"
        } else {
#line 93 "../hw/char/trace-events"
            qemu_log("nrf51_uart_write " "addr 0x%" PRIx64 " value 0x%" PRIx64 " size %u" "\n", addr, value, size);
#line 2448 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_nrf51_uart_write(uint64_t addr, uint64_t value, unsigned int size)
{
    if (true) {
        _nocheck__trace_nrf51_uart_write(addr, value, size);
    }
}

#define TRACE_SHAKTI_UART_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SHAKTI_UART_READ) || \
    false)

static inline void _nocheck__trace_shakti_uart_read(uint64_t addr, uint16_t r, unsigned int size)
{
    if (trace_event_get_state(TRACE_SHAKTI_UART_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 96 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:shakti_uart_read " "addr 0x%" PRIx64 " value 0x%" PRIx16 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, r, size);
#line 2475 "trace/trace-hw_char.h"
        } else {
#line 96 "../hw/char/trace-events"
            qemu_log("shakti_uart_read " "addr 0x%" PRIx64 " value 0x%" PRIx16 " size %u" "\n", addr, r, size);
#line 2479 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_shakti_uart_read(uint64_t addr, uint16_t r, unsigned int size)
{
    if (true) {
        _nocheck__trace_shakti_uart_read(addr, r, size);
    }
}

#define TRACE_SHAKTI_UART_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SHAKTI_UART_WRITE) || \
    false)

static inline void _nocheck__trace_shakti_uart_write(uint64_t addr, uint64_t value, unsigned int size)
{
    if (trace_event_get_state(TRACE_SHAKTI_UART_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 97 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:shakti_uart_write " "addr 0x%" PRIx64 " value 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value, size);
#line 2506 "trace/trace-hw_char.h"
        } else {
#line 97 "../hw/char/trace-events"
            qemu_log("shakti_uart_write " "addr 0x%" PRIx64 " value 0x%" PRIx64 " size %u" "\n", addr, value, size);
#line 2510 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_shakti_uart_write(uint64_t addr, uint64_t value, unsigned int size)
{
    if (true) {
        _nocheck__trace_shakti_uart_write(addr, value, size);
    }
}

#define TRACE_EXYNOS_UART_DMABUSY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_DMABUSY) || \
    false)

static inline void _nocheck__trace_exynos_uart_dmabusy(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_DMABUSY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 100 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_dmabusy " "UART%d: DMA busy (Rx buffer empty)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 2537 "trace/trace-hw_char.h"
        } else {
#line 100 "../hw/char/trace-events"
            qemu_log("exynos_uart_dmabusy " "UART%d: DMA busy (Rx buffer empty)" "\n", channel);
#line 2541 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_dmabusy(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_dmabusy(channel);
    }
}

#define TRACE_EXYNOS_UART_DMAREADY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_DMAREADY) || \
    false)

static inline void _nocheck__trace_exynos_uart_dmaready(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_DMAREADY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 101 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_dmaready " "UART%d: DMA ready" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 2568 "trace/trace-hw_char.h"
        } else {
#line 101 "../hw/char/trace-events"
            qemu_log("exynos_uart_dmaready " "UART%d: DMA ready" "\n", channel);
#line 2572 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_dmaready(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_dmaready(channel);
    }
}

#define TRACE_EXYNOS_UART_IRQ_RAISED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_IRQ_RAISED) || \
    false)

static inline void _nocheck__trace_exynos_uart_irq_raised(uint32_t channel, uint32_t reg)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_IRQ_RAISED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 102 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_irq_raised " "UART%d: IRQ raised: 0x%08"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, reg);
#line 2599 "trace/trace-hw_char.h"
        } else {
#line 102 "../hw/char/trace-events"
            qemu_log("exynos_uart_irq_raised " "UART%d: IRQ raised: 0x%08"PRIx32 "\n", channel, reg);
#line 2603 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_irq_raised(uint32_t channel, uint32_t reg)
{
    if (true) {
        _nocheck__trace_exynos_uart_irq_raised(channel, reg);
    }
}

#define TRACE_EXYNOS_UART_IRQ_LOWERED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_IRQ_LOWERED) || \
    false)

static inline void _nocheck__trace_exynos_uart_irq_lowered(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_IRQ_LOWERED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 103 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_irq_lowered " "UART%d: IRQ lowered" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 2630 "trace/trace-hw_char.h"
        } else {
#line 103 "../hw/char/trace-events"
            qemu_log("exynos_uart_irq_lowered " "UART%d: IRQ lowered" "\n", channel);
#line 2634 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_irq_lowered(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_irq_lowered(channel);
    }
}

#define TRACE_EXYNOS_UART_UPDATE_PARAMS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_UPDATE_PARAMS) || \
    false)

static inline void _nocheck__trace_exynos_uart_update_params(uint32_t channel, int speed, uint8_t parity, int data, int stop, uint64_t wordtime)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_UPDATE_PARAMS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 104 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_update_params " "UART%d: speed: %d, parity: %c, data bits: %d, stop bits: %d wordtime: %"PRId64"ns" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, speed, parity, data, stop, wordtime);
#line 2661 "trace/trace-hw_char.h"
        } else {
#line 104 "../hw/char/trace-events"
            qemu_log("exynos_uart_update_params " "UART%d: speed: %d, parity: %c, data bits: %d, stop bits: %d wordtime: %"PRId64"ns" "\n", channel, speed, parity, data, stop, wordtime);
#line 2665 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_update_params(uint32_t channel, int speed, uint8_t parity, int data, int stop, uint64_t wordtime)
{
    if (true) {
        _nocheck__trace_exynos_uart_update_params(channel, speed, parity, data, stop, wordtime);
    }
}

#define TRACE_EXYNOS_UART_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_WRITE) || \
    false)

static inline void _nocheck__trace_exynos_uart_write(uint32_t channel, uint32_t offset, const char * name, uint64_t val)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 105 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_write " "UART%d: <0x%04x> %s <- 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, offset, name, val);
#line 2692 "trace/trace-hw_char.h"
        } else {
#line 105 "../hw/char/trace-events"
            qemu_log("exynos_uart_write " "UART%d: <0x%04x> %s <- 0x%" PRIx64 "\n", channel, offset, name, val);
#line 2696 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_write(uint32_t channel, uint32_t offset, const char * name, uint64_t val)
{
    if (true) {
        _nocheck__trace_exynos_uart_write(channel, offset, name, val);
    }
}

#define TRACE_EXYNOS_UART_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_READ) || \
    false)

static inline void _nocheck__trace_exynos_uart_read(uint32_t channel, uint32_t offset, const char * name, uint64_t val)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 106 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_read " "UART%d: <0x%04x> %s -> 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, offset, name, val);
#line 2723 "trace/trace-hw_char.h"
        } else {
#line 106 "../hw/char/trace-events"
            qemu_log("exynos_uart_read " "UART%d: <0x%04x> %s -> 0x%" PRIx64 "\n", channel, offset, name, val);
#line 2727 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_read(uint32_t channel, uint32_t offset, const char * name, uint64_t val)
{
    if (true) {
        _nocheck__trace_exynos_uart_read(channel, offset, name, val);
    }
}

#define TRACE_EXYNOS_UART_RX_FIFO_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_RX_FIFO_RESET) || \
    false)

static inline void _nocheck__trace_exynos_uart_rx_fifo_reset(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_RX_FIFO_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 107 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_rx_fifo_reset " "UART%d: Rx FIFO Reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 2754 "trace/trace-hw_char.h"
        } else {
#line 107 "../hw/char/trace-events"
            qemu_log("exynos_uart_rx_fifo_reset " "UART%d: Rx FIFO Reset" "\n", channel);
#line 2758 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_rx_fifo_reset(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_rx_fifo_reset(channel);
    }
}

#define TRACE_EXYNOS_UART_TX_FIFO_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_TX_FIFO_RESET) || \
    false)

static inline void _nocheck__trace_exynos_uart_tx_fifo_reset(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_TX_FIFO_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 108 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_tx_fifo_reset " "UART%d: Tx FIFO Reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 2785 "trace/trace-hw_char.h"
        } else {
#line 108 "../hw/char/trace-events"
            qemu_log("exynos_uart_tx_fifo_reset " "UART%d: Tx FIFO Reset" "\n", channel);
#line 2789 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_tx_fifo_reset(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_tx_fifo_reset(channel);
    }
}

#define TRACE_EXYNOS_UART_TX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_TX) || \
    false)

static inline void _nocheck__trace_exynos_uart_tx(uint32_t channel, uint8_t ch)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_TX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 109 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_tx " "UART%d: Tx 0x%02"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, ch);
#line 2816 "trace/trace-hw_char.h"
        } else {
#line 109 "../hw/char/trace-events"
            qemu_log("exynos_uart_tx " "UART%d: Tx 0x%02"PRIx32 "\n", channel, ch);
#line 2820 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_tx(uint32_t channel, uint8_t ch)
{
    if (true) {
        _nocheck__trace_exynos_uart_tx(channel, ch);
    }
}

#define TRACE_EXYNOS_UART_INTCLR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_INTCLR) || \
    false)

static inline void _nocheck__trace_exynos_uart_intclr(uint32_t channel, uint32_t reg)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_INTCLR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 110 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_intclr " "UART%d: interrupts cleared: 0x%08"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, reg);
#line 2847 "trace/trace-hw_char.h"
        } else {
#line 110 "../hw/char/trace-events"
            qemu_log("exynos_uart_intclr " "UART%d: interrupts cleared: 0x%08"PRIx32 "\n", channel, reg);
#line 2851 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_intclr(uint32_t channel, uint32_t reg)
{
    if (true) {
        _nocheck__trace_exynos_uart_intclr(channel, reg);
    }
}

#define TRACE_EXYNOS_UART_RO_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_RO_WRITE) || \
    false)

static inline void _nocheck__trace_exynos_uart_ro_write(uint32_t channel, const char * name, uint32_t reg)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_RO_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 111 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_ro_write " "UART%d: Trying to write into RO register: %s [0x%04"PRIx32"]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, name, reg);
#line 2878 "trace/trace-hw_char.h"
        } else {
#line 111 "../hw/char/trace-events"
            qemu_log("exynos_uart_ro_write " "UART%d: Trying to write into RO register: %s [0x%04"PRIx32"]" "\n", channel, name, reg);
#line 2882 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_ro_write(uint32_t channel, const char * name, uint32_t reg)
{
    if (true) {
        _nocheck__trace_exynos_uart_ro_write(channel, name, reg);
    }
}

#define TRACE_EXYNOS_UART_RX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_RX) || \
    false)

static inline void _nocheck__trace_exynos_uart_rx(uint32_t channel, uint8_t ch)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_RX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 112 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_rx " "UART%d: Rx 0x%02"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, ch);
#line 2909 "trace/trace-hw_char.h"
        } else {
#line 112 "../hw/char/trace-events"
            qemu_log("exynos_uart_rx " "UART%d: Rx 0x%02"PRIx32 "\n", channel, ch);
#line 2913 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_rx(uint32_t channel, uint8_t ch)
{
    if (true) {
        _nocheck__trace_exynos_uart_rx(channel, ch);
    }
}

#define TRACE_EXYNOS_UART_RX_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_RX_ERROR) || \
    false)

static inline void _nocheck__trace_exynos_uart_rx_error(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_RX_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 113 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_rx_error " "UART%d: Rx error" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 2940 "trace/trace-hw_char.h"
        } else {
#line 113 "../hw/char/trace-events"
            qemu_log("exynos_uart_rx_error " "UART%d: Rx error" "\n", channel);
#line 2944 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_rx_error(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_rx_error(channel);
    }
}

#define TRACE_EXYNOS_UART_WO_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_WO_READ) || \
    false)

static inline void _nocheck__trace_exynos_uart_wo_read(uint32_t channel, const char * name, uint32_t reg)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_WO_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 114 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_wo_read " "UART%d: Trying to read from WO register: %s [0x%04"PRIx32"]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, name, reg);
#line 2971 "trace/trace-hw_char.h"
        } else {
#line 114 "../hw/char/trace-events"
            qemu_log("exynos_uart_wo_read " "UART%d: Trying to read from WO register: %s [0x%04"PRIx32"]" "\n", channel, name, reg);
#line 2975 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_wo_read(uint32_t channel, const char * name, uint32_t reg)
{
    if (true) {
        _nocheck__trace_exynos_uart_wo_read(channel, name, reg);
    }
}

#define TRACE_EXYNOS_UART_RXSIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_RXSIZE) || \
    false)

static inline void _nocheck__trace_exynos_uart_rxsize(uint32_t channel, uint32_t size)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_RXSIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 115 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_rxsize " "UART%d: Rx FIFO size: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, size);
#line 3002 "trace/trace-hw_char.h"
        } else {
#line 115 "../hw/char/trace-events"
            qemu_log("exynos_uart_rxsize " "UART%d: Rx FIFO size: %d" "\n", channel, size);
#line 3006 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_rxsize(uint32_t channel, uint32_t size)
{
    if (true) {
        _nocheck__trace_exynos_uart_rxsize(channel, size);
    }
}

#define TRACE_EXYNOS_UART_CHANNEL_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_CHANNEL_ERROR) || \
    false)

static inline void _nocheck__trace_exynos_uart_channel_error(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_CHANNEL_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 116 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_channel_error " "Wrong UART channel number: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 3033 "trace/trace-hw_char.h"
        } else {
#line 116 "../hw/char/trace-events"
            qemu_log("exynos_uart_channel_error " "Wrong UART channel number: %d" "\n", channel);
#line 3037 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_channel_error(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_channel_error(channel);
    }
}

#define TRACE_EXYNOS_UART_RX_TIMEOUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_RX_TIMEOUT) || \
    false)

static inline void _nocheck__trace_exynos_uart_rx_timeout(uint32_t channel, uint32_t stat, uint32_t intsp)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_RX_TIMEOUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 117 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_rx_timeout " "UART%d: Rx timeout stat=0x%x intsp=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, stat, intsp);
#line 3064 "trace/trace-hw_char.h"
        } else {
#line 117 "../hw/char/trace-events"
            qemu_log("exynos_uart_rx_timeout " "UART%d: Rx timeout stat=0x%x intsp=0x%x" "\n", channel, stat, intsp);
#line 3068 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_rx_timeout(uint32_t channel, uint32_t stat, uint32_t intsp)
{
    if (true) {
        _nocheck__trace_exynos_uart_rx_timeout(channel, stat, intsp);
    }
}

#define TRACE_CADENCE_UART_BAUDRATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CADENCE_UART_BAUDRATE) || \
    false)

static inline void _nocheck__trace_cadence_uart_baudrate(unsigned baudrate)
{
    if (trace_event_get_state(TRACE_CADENCE_UART_BAUDRATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 120 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cadence_uart_baudrate " "baudrate %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , baudrate);
#line 3095 "trace/trace-hw_char.h"
        } else {
#line 120 "../hw/char/trace-events"
            qemu_log("cadence_uart_baudrate " "baudrate %u" "\n", baudrate);
#line 3099 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cadence_uart_baudrate(unsigned baudrate)
{
    if (true) {
        _nocheck__trace_cadence_uart_baudrate(baudrate);
    }
}

#define TRACE_SH_SERIAL_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SH_SERIAL_READ) || \
    false)

static inline void _nocheck__trace_sh_serial_read(char * id, unsigned size, uint64_t offs, uint64_t val)
{
    if (trace_event_get_state(TRACE_SH_SERIAL_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 123 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:sh_serial_read " " %s size %d offs 0x%02" PRIx64 " -> 0x%02" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, size, offs, val);
#line 3126 "trace/trace-hw_char.h"
        } else {
#line 123 "../hw/char/trace-events"
            qemu_log("sh_serial_read " " %s size %d offs 0x%02" PRIx64 " -> 0x%02" PRIx64 "\n", id, size, offs, val);
#line 3130 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_sh_serial_read(char * id, unsigned size, uint64_t offs, uint64_t val)
{
    if (true) {
        _nocheck__trace_sh_serial_read(id, size, offs, val);
    }
}

#define TRACE_SH_SERIAL_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SH_SERIAL_WRITE) || \
    false)

static inline void _nocheck__trace_sh_serial_write(char * id, unsigned size, uint64_t offs, uint64_t val)
{
    if (trace_event_get_state(TRACE_SH_SERIAL_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 124 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:sh_serial_write " "%s size %d offs 0x%02" PRIx64 " <- 0x%02" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, size, offs, val);
#line 3157 "trace/trace-hw_char.h"
        } else {
#line 124 "../hw/char/trace-events"
            qemu_log("sh_serial_write " "%s size %d offs 0x%02" PRIx64 " <- 0x%02" PRIx64 "\n", id, size, offs, val);
#line 3161 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_sh_serial_write(char * id, unsigned size, uint64_t offs, uint64_t val)
{
    if (true) {
        _nocheck__trace_sh_serial_write(id, size, offs, val);
    }
}

#define TRACE_STM32L4X5_USART_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STM32L4X5_USART_READ) || \
    false)

static inline void _nocheck__trace_stm32l4x5_usart_read(uint64_t addr, uint32_t data)
{
    if (trace_event_get_state(TRACE_STM32L4X5_USART_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 127 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:stm32l4x5_usart_read " "USART: Read <0x%" PRIx64 "> -> 0x%" PRIx32 "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data);
#line 3188 "trace/trace-hw_char.h"
        } else {
#line 127 "../hw/char/trace-events"
            qemu_log("stm32l4x5_usart_read " "USART: Read <0x%" PRIx64 "> -> 0x%" PRIx32 "" "\n", addr, data);
#line 3192 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_stm32l4x5_usart_read(uint64_t addr, uint32_t data)
{
    if (true) {
        _nocheck__trace_stm32l4x5_usart_read(addr, data);
    }
}

#define TRACE_STM32L4X5_USART_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STM32L4X5_USART_WRITE) || \
    false)

static inline void _nocheck__trace_stm32l4x5_usart_write(uint64_t addr, uint32_t data)
{
    if (trace_event_get_state(TRACE_STM32L4X5_USART_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 128 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:stm32l4x5_usart_write " "USART: Write <0x%" PRIx64 "> <- 0x%" PRIx32 "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data);
#line 3219 "trace/trace-hw_char.h"
        } else {
#line 128 "../hw/char/trace-events"
            qemu_log("stm32l4x5_usart_write " "USART: Write <0x%" PRIx64 "> <- 0x%" PRIx32 "" "\n", addr, data);
#line 3223 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_stm32l4x5_usart_write(uint64_t addr, uint32_t data)
{
    if (true) {
        _nocheck__trace_stm32l4x5_usart_write(addr, data);
    }
}

#define TRACE_STM32L4X5_USART_RX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STM32L4X5_USART_RX) || \
    false)

static inline void _nocheck__trace_stm32l4x5_usart_rx(uint8_t c)
{
    if (trace_event_get_state(TRACE_STM32L4X5_USART_RX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 129 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:stm32l4x5_usart_rx " "USART: got character 0x%x from backend" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , c);
#line 3250 "trace/trace-hw_char.h"
        } else {
#line 129 "../hw/char/trace-events"
            qemu_log("stm32l4x5_usart_rx " "USART: got character 0x%x from backend" "\n", c);
#line 3254 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_stm32l4x5_usart_rx(uint8_t c)
{
    if (true) {
        _nocheck__trace_stm32l4x5_usart_rx(c);
    }
}

#define TRACE_STM32L4X5_USART_TX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STM32L4X5_USART_TX) || \
    false)

static inline void _nocheck__trace_stm32l4x5_usart_tx(uint8_t c)
{
    if (trace_event_get_state(TRACE_STM32L4X5_USART_TX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 130 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:stm32l4x5_usart_tx " "USART: character 0x%x sent to backend" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , c);
#line 3281 "trace/trace-hw_char.h"
        } else {
#line 130 "../hw/char/trace-events"
            qemu_log("stm32l4x5_usart_tx " "USART: character 0x%x sent to backend" "\n", c);
#line 3285 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_stm32l4x5_usart_tx(uint8_t c)
{
    if (true) {
        _nocheck__trace_stm32l4x5_usart_tx(c);
    }
}

#define TRACE_STM32L4X5_USART_TX_PENDING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STM32L4X5_USART_TX_PENDING) || \
    false)

static inline void _nocheck__trace_stm32l4x5_usart_tx_pending(void)
{
    if (trace_event_get_state(TRACE_STM32L4X5_USART_TX_PENDING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 131 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:stm32l4x5_usart_tx_pending " "USART: character send to backend pending" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3312 "trace/trace-hw_char.h"
        } else {
#line 131 "../hw/char/trace-events"
            qemu_log("stm32l4x5_usart_tx_pending " "USART: character send to backend pending" "\n");
#line 3316 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_stm32l4x5_usart_tx_pending(void)
{
    if (true) {
        _nocheck__trace_stm32l4x5_usart_tx_pending();
    }
}

#define TRACE_STM32L4X5_USART_IRQ_RAISED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STM32L4X5_USART_IRQ_RAISED) || \
    false)

static inline void _nocheck__trace_stm32l4x5_usart_irq_raised(uint32_t reg)
{
    if (trace_event_get_state(TRACE_STM32L4X5_USART_IRQ_RAISED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 132 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:stm32l4x5_usart_irq_raised " "USART: IRQ raised: 0x%08"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg);
#line 3343 "trace/trace-hw_char.h"
        } else {
#line 132 "../hw/char/trace-events"
            qemu_log("stm32l4x5_usart_irq_raised " "USART: IRQ raised: 0x%08"PRIx32 "\n", reg);
#line 3347 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_stm32l4x5_usart_irq_raised(uint32_t reg)
{
    if (true) {
        _nocheck__trace_stm32l4x5_usart_irq_raised(reg);
    }
}

#define TRACE_STM32L4X5_USART_IRQ_LOWERED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STM32L4X5_USART_IRQ_LOWERED) || \
    false)

static inline void _nocheck__trace_stm32l4x5_usart_irq_lowered(void)
{
    if (trace_event_get_state(TRACE_STM32L4X5_USART_IRQ_LOWERED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 133 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:stm32l4x5_usart_irq_lowered " "USART: IRQ lowered" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3374 "trace/trace-hw_char.h"
        } else {
#line 133 "../hw/char/trace-events"
            qemu_log("stm32l4x5_usart_irq_lowered " "USART: IRQ lowered" "\n");
#line 3378 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_stm32l4x5_usart_irq_lowered(void)
{
    if (true) {
        _nocheck__trace_stm32l4x5_usart_irq_lowered();
    }
}

#define TRACE_STM32L4X5_USART_OVERRUN_DETECTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STM32L4X5_USART_OVERRUN_DETECTED) || \
    false)

static inline void _nocheck__trace_stm32l4x5_usart_overrun_detected(uint8_t current, uint8_t received)
{
    if (trace_event_get_state(TRACE_STM32L4X5_USART_OVERRUN_DETECTED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 134 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:stm32l4x5_usart_overrun_detected " "USART: Overrun detected, RDR='0x%x', received 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , current, received);
#line 3405 "trace/trace-hw_char.h"
        } else {
#line 134 "../hw/char/trace-events"
            qemu_log("stm32l4x5_usart_overrun_detected " "USART: Overrun detected, RDR='0x%x', received 0x%x" "\n", current, received);
#line 3409 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_stm32l4x5_usart_overrun_detected(uint8_t current, uint8_t received)
{
    if (true) {
        _nocheck__trace_stm32l4x5_usart_overrun_detected(current, received);
    }
}

#define TRACE_STM32L4X5_USART_RECEIVER_NOT_ENABLED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STM32L4X5_USART_RECEIVER_NOT_ENABLED) || \
    false)

static inline void _nocheck__trace_stm32l4x5_usart_receiver_not_enabled(uint8_t ue_bit, uint8_t re_bit)
{
    if (trace_event_get_state(TRACE_STM32L4X5_USART_RECEIVER_NOT_ENABLED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 135 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:stm32l4x5_usart_receiver_not_enabled " "USART: Receiver not enabled, UE=0x%x, RE=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ue_bit, re_bit);
#line 3436 "trace/trace-hw_char.h"
        } else {
#line 135 "../hw/char/trace-events"
            qemu_log("stm32l4x5_usart_receiver_not_enabled " "USART: Receiver not enabled, UE=0x%x, RE=0x%x" "\n", ue_bit, re_bit);
#line 3440 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_stm32l4x5_usart_receiver_not_enabled(uint8_t ue_bit, uint8_t re_bit)
{
    if (true) {
        _nocheck__trace_stm32l4x5_usart_receiver_not_enabled(ue_bit, re_bit);
    }
}

#define TRACE_STM32L4X5_USART_UPDATE_PARAMS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STM32L4X5_USART_UPDATE_PARAMS) || \
    false)

static inline void _nocheck__trace_stm32l4x5_usart_update_params(int speed, uint8_t parity, int data, int stop)
{
    if (trace_event_get_state(TRACE_STM32L4X5_USART_UPDATE_PARAMS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 136 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:stm32l4x5_usart_update_params " "USART: speed: %d, parity: %c, data bits: %d, stop bits: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , speed, parity, data, stop);
#line 3467 "trace/trace-hw_char.h"
        } else {
#line 136 "../hw/char/trace-events"
            qemu_log("stm32l4x5_usart_update_params " "USART: speed: %d, parity: %c, data bits: %d, stop bits: %d" "\n", speed, parity, data, stop);
#line 3471 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_stm32l4x5_usart_update_params(int speed, uint8_t parity, int data, int stop)
{
    if (true) {
        _nocheck__trace_stm32l4x5_usart_update_params(speed, parity, data, stop);
    }
}

#define TRACE_XEN_CONSOLE_CONNECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_CONSOLE_CONNECT) || \
    false)

static inline void _nocheck__trace_xen_console_connect(unsigned int idx, unsigned int ring_ref, unsigned int port, unsigned int limit)
{
    if (trace_event_get_state(TRACE_XEN_CONSOLE_CONNECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 139 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:xen_console_connect " "idx %u ring_ref %u port %u limit %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx, ring_ref, port, limit);
#line 3498 "trace/trace-hw_char.h"
        } else {
#line 139 "../hw/char/trace-events"
            qemu_log("xen_console_connect " "idx %u ring_ref %u port %u limit %u" "\n", idx, ring_ref, port, limit);
#line 3502 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_xen_console_connect(unsigned int idx, unsigned int ring_ref, unsigned int port, unsigned int limit)
{
    if (true) {
        _nocheck__trace_xen_console_connect(idx, ring_ref, port, limit);
    }
}

#define TRACE_XEN_CONSOLE_DISCONNECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_CONSOLE_DISCONNECT) || \
    false)

static inline void _nocheck__trace_xen_console_disconnect(unsigned int idx)
{
    if (trace_event_get_state(TRACE_XEN_CONSOLE_DISCONNECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 140 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:xen_console_disconnect " "idx %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx);
#line 3529 "trace/trace-hw_char.h"
        } else {
#line 140 "../hw/char/trace-events"
            qemu_log("xen_console_disconnect " "idx %u" "\n", idx);
#line 3533 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_xen_console_disconnect(unsigned int idx)
{
    if (true) {
        _nocheck__trace_xen_console_disconnect(idx);
    }
}

#define TRACE_XEN_CONSOLE_UNREALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_CONSOLE_UNREALIZE) || \
    false)

static inline void _nocheck__trace_xen_console_unrealize(unsigned int idx)
{
    if (trace_event_get_state(TRACE_XEN_CONSOLE_UNREALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 141 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:xen_console_unrealize " "idx %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx);
#line 3560 "trace/trace-hw_char.h"
        } else {
#line 141 "../hw/char/trace-events"
            qemu_log("xen_console_unrealize " "idx %u" "\n", idx);
#line 3564 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_xen_console_unrealize(unsigned int idx)
{
    if (true) {
        _nocheck__trace_xen_console_unrealize(idx);
    }
}

#define TRACE_XEN_CONSOLE_REALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_CONSOLE_REALIZE) || \
    false)

static inline void _nocheck__trace_xen_console_realize(unsigned int idx, const char * chrdev)
{
    if (trace_event_get_state(TRACE_XEN_CONSOLE_REALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 142 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:xen_console_realize " "idx %u chrdev %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx, chrdev);
#line 3591 "trace/trace-hw_char.h"
        } else {
#line 142 "../hw/char/trace-events"
            qemu_log("xen_console_realize " "idx %u chrdev %s" "\n", idx, chrdev);
#line 3595 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_xen_console_realize(unsigned int idx, const char * chrdev)
{
    if (true) {
        _nocheck__trace_xen_console_realize(idx, chrdev);
    }
}

#define TRACE_XEN_CONSOLE_DEVICE_CREATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_CONSOLE_DEVICE_CREATE) || \
    false)

static inline void _nocheck__trace_xen_console_device_create(unsigned int idx)
{
    if (trace_event_get_state(TRACE_XEN_CONSOLE_DEVICE_CREATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 143 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:xen_console_device_create " "idx %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx);
#line 3622 "trace/trace-hw_char.h"
        } else {
#line 143 "../hw/char/trace-events"
            qemu_log("xen_console_device_create " "idx %u" "\n", idx);
#line 3626 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_xen_console_device_create(unsigned int idx)
{
    if (true) {
        _nocheck__trace_xen_console_device_create(idx);
    }
}

#define TRACE_XEN_CONSOLE_DEVICE_DESTROY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_CONSOLE_DEVICE_DESTROY) || \
    false)

static inline void _nocheck__trace_xen_console_device_destroy(unsigned int idx)
{
    if (trace_event_get_state(TRACE_XEN_CONSOLE_DEVICE_DESTROY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 144 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:xen_console_device_destroy " "idx %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx);
#line 3653 "trace/trace-hw_char.h"
        } else {
#line 144 "../hw/char/trace-events"
            qemu_log("xen_console_device_destroy " "idx %u" "\n", idx);
#line 3657 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_xen_console_device_destroy(unsigned int idx)
{
    if (true) {
        _nocheck__trace_xen_console_device_destroy(idx);
    }
}

#define TRACE_STM32F2XX_USART_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STM32F2XX_USART_READ) || \
    false)

static inline void _nocheck__trace_stm32f2xx_usart_read(char * id, unsigned size, uint64_t ofs, uint64_t val)
{
    if (trace_event_get_state(TRACE_STM32F2XX_USART_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 147 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:stm32f2xx_usart_read " " %s size %d ofs 0x%02" PRIx64 " -> 0x%02" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, size, ofs, val);
#line 3684 "trace/trace-hw_char.h"
        } else {
#line 147 "../hw/char/trace-events"
            qemu_log("stm32f2xx_usart_read " " %s size %d ofs 0x%02" PRIx64 " -> 0x%02" PRIx64 "\n", id, size, ofs, val);
#line 3688 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_stm32f2xx_usart_read(char * id, unsigned size, uint64_t ofs, uint64_t val)
{
    if (true) {
        _nocheck__trace_stm32f2xx_usart_read(id, size, ofs, val);
    }
}

#define TRACE_STM32F2XX_USART_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STM32F2XX_USART_WRITE) || \
    false)

static inline void _nocheck__trace_stm32f2xx_usart_write(char * id, unsigned size, uint64_t ofs, uint64_t val)
{
    if (trace_event_get_state(TRACE_STM32F2XX_USART_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 148 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:stm32f2xx_usart_write " "%s size %d ofs 0x%02" PRIx64 " <- 0x%02" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, size, ofs, val);
#line 3715 "trace/trace-hw_char.h"
        } else {
#line 148 "../hw/char/trace-events"
            qemu_log("stm32f2xx_usart_write " "%s size %d ofs 0x%02" PRIx64 " <- 0x%02" PRIx64 "\n", id, size, ofs, val);
#line 3719 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_stm32f2xx_usart_write(char * id, unsigned size, uint64_t ofs, uint64_t val)
{
    if (true) {
        _nocheck__trace_stm32f2xx_usart_write(id, size, ofs, val);
    }
}

#define TRACE_STM32F2XX_USART_DROP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STM32F2XX_USART_DROP) || \
    false)

static inline void _nocheck__trace_stm32f2xx_usart_drop(char * id)
{
    if (trace_event_get_state(TRACE_STM32F2XX_USART_DROP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 149 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:stm32f2xx_usart_drop " " %s dropping the chars" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id);
#line 3746 "trace/trace-hw_char.h"
        } else {
#line 149 "../hw/char/trace-events"
            qemu_log("stm32f2xx_usart_drop " " %s dropping the chars" "\n", id);
#line 3750 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_stm32f2xx_usart_drop(char * id)
{
    if (true) {
        _nocheck__trace_stm32f2xx_usart_drop(id);
    }
}

#define TRACE_STM32F2XX_USART_RECEIVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STM32F2XX_USART_RECEIVE) || \
    false)

static inline void _nocheck__trace_stm32f2xx_usart_receive(char * id, uint8_t chr)
{
    if (trace_event_get_state(TRACE_STM32F2XX_USART_RECEIVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 150 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:stm32f2xx_usart_receive " " %s receiving '%c'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, chr);
#line 3777 "trace/trace-hw_char.h"
        } else {
#line 150 "../hw/char/trace-events"
            qemu_log("stm32f2xx_usart_receive " " %s receiving '%c'" "\n", id, chr);
#line 3781 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_stm32f2xx_usart_receive(char * id, uint8_t chr)
{
    if (true) {
        _nocheck__trace_stm32f2xx_usart_receive(id, chr);
    }
}

#define TRACE_HTIF_UART_WRITE_TO_HOST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HTIF_UART_WRITE_TO_HOST) || \
    false)

static inline void _nocheck__trace_htif_uart_write_to_host(uint8_t device, uint8_t cmd, uint64_t payload)
{
    if (trace_event_get_state(TRACE_HTIF_UART_WRITE_TO_HOST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 153 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:htif_uart_write_to_host " "device: %u cmd: %02u payload: %016" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , device, cmd, payload);
#line 3808 "trace/trace-hw_char.h"
        } else {
#line 153 "../hw/char/trace-events"
            qemu_log("htif_uart_write_to_host " "device: %u cmd: %02u payload: %016" PRIx64 "\n", device, cmd, payload);
#line 3812 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_htif_uart_write_to_host(uint8_t device, uint8_t cmd, uint64_t payload)
{
    if (true) {
        _nocheck__trace_htif_uart_write_to_host(device, cmd, payload);
    }
}

#define TRACE_HTIF_UART_UNKNOWN_DEVICE_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HTIF_UART_UNKNOWN_DEVICE_COMMAND) || \
    false)

static inline void _nocheck__trace_htif_uart_unknown_device_command(uint8_t device, uint8_t cmd, uint64_t payload)
{
    if (trace_event_get_state(TRACE_HTIF_UART_UNKNOWN_DEVICE_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 154 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:htif_uart_unknown_device_command " "device: %u cmd: %02u payload: %016" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , device, cmd, payload);
#line 3839 "trace/trace-hw_char.h"
        } else {
#line 154 "../hw/char/trace-events"
            qemu_log("htif_uart_unknown_device_command " "device: %u cmd: %02u payload: %016" PRIx64 "\n", device, cmd, payload);
#line 3843 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_htif_uart_unknown_device_command(uint8_t device, uint8_t cmd, uint64_t payload)
{
    if (true) {
        _nocheck__trace_htif_uart_unknown_device_command(device, cmd, payload);
    }
}
#endif /* TRACE_HW_CHAR_GENERATED_TRACERS_H */
