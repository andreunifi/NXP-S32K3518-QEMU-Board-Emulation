/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_EBPF_GENERATED_TRACERS_H
#define TRACE_EBPF_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_EBPF_RSS_LOAD_EVENT;
extern TraceEvent _TRACE_EBPF_RSS_LOAD_ERROR_EVENT;
extern TraceEvent _TRACE_EBPF_RSS_MMAP_EVENT;
extern TraceEvent _TRACE_EBPF_RSS_MMAP_ERROR_EVENT;
extern TraceEvent _TRACE_EBPF_RSS_OPEN_ERROR_EVENT;
extern TraceEvent _TRACE_EBPF_RSS_SET_DATA_EVENT;
extern TraceEvent _TRACE_EBPF_RSS_UNLOAD_EVENT;
extern uint16_t _TRACE_EBPF_RSS_LOAD_DSTATE;
extern uint16_t _TRACE_EBPF_RSS_LOAD_ERROR_DSTATE;
extern uint16_t _TRACE_EBPF_RSS_MMAP_DSTATE;
extern uint16_t _TRACE_EBPF_RSS_MMAP_ERROR_DSTATE;
extern uint16_t _TRACE_EBPF_RSS_OPEN_ERROR_DSTATE;
extern uint16_t _TRACE_EBPF_RSS_SET_DATA_DSTATE;
extern uint16_t _TRACE_EBPF_RSS_UNLOAD_DSTATE;
#define TRACE_EBPF_RSS_LOAD_ENABLED 1
#define TRACE_EBPF_RSS_LOAD_ERROR_ENABLED 1
#define TRACE_EBPF_RSS_MMAP_ENABLED 1
#define TRACE_EBPF_RSS_MMAP_ERROR_ENABLED 1
#define TRACE_EBPF_RSS_OPEN_ERROR_ENABLED 1
#define TRACE_EBPF_RSS_SET_DATA_ENABLED 1
#define TRACE_EBPF_RSS_UNLOAD_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_EBPF_RSS_LOAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EBPF_RSS_LOAD) || \
    false)

static inline void _nocheck__trace_ebpf_rss_load(void * ctx, int progfd, int cfgfd, int toepfd, int indirfd)
{
    if (trace_event_get_state(TRACE_EBPF_RSS_LOAD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "../ebpf/trace-events"
            qemu_log("%d@%zu.%06zu:ebpf_rss_load " "ctx=%p program-fd=%d config-fd=%d toeplitz-fd=%d indirection-fd=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ctx, progfd, cfgfd, toepfd, indirfd);
#line 49 "trace/trace-ebpf.h"
        } else {
#line 4 "../ebpf/trace-events"
            qemu_log("ebpf_rss_load " "ctx=%p program-fd=%d config-fd=%d toeplitz-fd=%d indirection-fd=%d" "\n", ctx, progfd, cfgfd, toepfd, indirfd);
#line 53 "trace/trace-ebpf.h"
        }
    }
}

static inline void trace_ebpf_rss_load(void * ctx, int progfd, int cfgfd, int toepfd, int indirfd)
{
    if (true) {
        _nocheck__trace_ebpf_rss_load(ctx, progfd, cfgfd, toepfd, indirfd);
    }
}

#define TRACE_EBPF_RSS_LOAD_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EBPF_RSS_LOAD_ERROR) || \
    false)

static inline void _nocheck__trace_ebpf_rss_load_error(void * ctx)
{
    if (trace_event_get_state(TRACE_EBPF_RSS_LOAD_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "../ebpf/trace-events"
            qemu_log("%d@%zu.%06zu:ebpf_rss_load_error " "ctx=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ctx);
#line 80 "trace/trace-ebpf.h"
        } else {
#line 5 "../ebpf/trace-events"
            qemu_log("ebpf_rss_load_error " "ctx=%p" "\n", ctx);
#line 84 "trace/trace-ebpf.h"
        }
    }
}

static inline void trace_ebpf_rss_load_error(void * ctx)
{
    if (true) {
        _nocheck__trace_ebpf_rss_load_error(ctx);
    }
}

#define TRACE_EBPF_RSS_MMAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EBPF_RSS_MMAP) || \
    false)

static inline void _nocheck__trace_ebpf_rss_mmap(void * ctx, void * cfgptr, void * toepptr, void * indirptr)
{
    if (trace_event_get_state(TRACE_EBPF_RSS_MMAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 6 "../ebpf/trace-events"
            qemu_log("%d@%zu.%06zu:ebpf_rss_mmap " "ctx=%p config-ptr=%p toeplitz-ptr=%p indirection-ptr=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ctx, cfgptr, toepptr, indirptr);
#line 111 "trace/trace-ebpf.h"
        } else {
#line 6 "../ebpf/trace-events"
            qemu_log("ebpf_rss_mmap " "ctx=%p config-ptr=%p toeplitz-ptr=%p indirection-ptr=%p" "\n", ctx, cfgptr, toepptr, indirptr);
#line 115 "trace/trace-ebpf.h"
        }
    }
}

static inline void trace_ebpf_rss_mmap(void * ctx, void * cfgptr, void * toepptr, void * indirptr)
{
    if (true) {
        _nocheck__trace_ebpf_rss_mmap(ctx, cfgptr, toepptr, indirptr);
    }
}

#define TRACE_EBPF_RSS_MMAP_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EBPF_RSS_MMAP_ERROR) || \
    false)

static inline void _nocheck__trace_ebpf_rss_mmap_error(void * ctx, const char * object)
{
    if (trace_event_get_state(TRACE_EBPF_RSS_MMAP_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 7 "../ebpf/trace-events"
            qemu_log("%d@%zu.%06zu:ebpf_rss_mmap_error " "ctx=%p object=%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ctx, object);
#line 142 "trace/trace-ebpf.h"
        } else {
#line 7 "../ebpf/trace-events"
            qemu_log("ebpf_rss_mmap_error " "ctx=%p object=%s" "\n", ctx, object);
#line 146 "trace/trace-ebpf.h"
        }
    }
}

static inline void trace_ebpf_rss_mmap_error(void * ctx, const char * object)
{
    if (true) {
        _nocheck__trace_ebpf_rss_mmap_error(ctx, object);
    }
}

#define TRACE_EBPF_RSS_OPEN_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EBPF_RSS_OPEN_ERROR) || \
    false)

static inline void _nocheck__trace_ebpf_rss_open_error(void * ctx)
{
    if (trace_event_get_state(TRACE_EBPF_RSS_OPEN_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "../ebpf/trace-events"
            qemu_log("%d@%zu.%06zu:ebpf_rss_open_error " "ctx=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ctx);
#line 173 "trace/trace-ebpf.h"
        } else {
#line 8 "../ebpf/trace-events"
            qemu_log("ebpf_rss_open_error " "ctx=%p" "\n", ctx);
#line 177 "trace/trace-ebpf.h"
        }
    }
}

static inline void trace_ebpf_rss_open_error(void * ctx)
{
    if (true) {
        _nocheck__trace_ebpf_rss_open_error(ctx);
    }
}

#define TRACE_EBPF_RSS_SET_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EBPF_RSS_SET_DATA) || \
    false)

static inline void _nocheck__trace_ebpf_rss_set_data(void * ctx, void * cfgptr, void * toepptr, void * indirptr)
{
    if (trace_event_get_state(TRACE_EBPF_RSS_SET_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "../ebpf/trace-events"
            qemu_log("%d@%zu.%06zu:ebpf_rss_set_data " "ctx=%p config-ptr=%p toeplitz-ptr=%p indirection-ptr=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ctx, cfgptr, toepptr, indirptr);
#line 204 "trace/trace-ebpf.h"
        } else {
#line 9 "../ebpf/trace-events"
            qemu_log("ebpf_rss_set_data " "ctx=%p config-ptr=%p toeplitz-ptr=%p indirection-ptr=%p" "\n", ctx, cfgptr, toepptr, indirptr);
#line 208 "trace/trace-ebpf.h"
        }
    }
}

static inline void trace_ebpf_rss_set_data(void * ctx, void * cfgptr, void * toepptr, void * indirptr)
{
    if (true) {
        _nocheck__trace_ebpf_rss_set_data(ctx, cfgptr, toepptr, indirptr);
    }
}

#define TRACE_EBPF_RSS_UNLOAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EBPF_RSS_UNLOAD) || \
    false)

static inline void _nocheck__trace_ebpf_rss_unload(void * ctx)
{
    if (trace_event_get_state(TRACE_EBPF_RSS_UNLOAD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "../ebpf/trace-events"
            qemu_log("%d@%zu.%06zu:ebpf_rss_unload " "rss unload ctx=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ctx);
#line 235 "trace/trace-ebpf.h"
        } else {
#line 10 "../ebpf/trace-events"
            qemu_log("ebpf_rss_unload " "rss unload ctx=%p" "\n", ctx);
#line 239 "trace/trace-ebpf.h"
        }
    }
}

static inline void trace_ebpf_rss_unload(void * ctx)
{
    if (true) {
        _nocheck__trace_ebpf_rss_unload(ctx);
    }
}
#endif /* TRACE_EBPF_GENERATED_TRACERS_H */
