/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_SYSTEM_GENERATED_TRACERS_H
#define TRACE_SYSTEM_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_BALLOON_EVENT_EVENT;
extern TraceEvent _TRACE_DMA_BLK_IO_EVENT;
extern TraceEvent _TRACE_DMA_AIO_CANCEL_EVENT;
extern TraceEvent _TRACE_DMA_COMPLETE_EVENT;
extern TraceEvent _TRACE_DMA_BLK_CB_EVENT;
extern TraceEvent _TRACE_DMA_MAP_WAIT_EVENT;
extern TraceEvent _TRACE_CPU_IN_EVENT;
extern TraceEvent _TRACE_CPU_OUT_EVENT;
extern TraceEvent _TRACE_MEMORY_REGION_OPS_READ_EVENT;
extern TraceEvent _TRACE_MEMORY_REGION_OPS_WRITE_EVENT;
extern TraceEvent _TRACE_MEMORY_REGION_SUBPAGE_READ_EVENT;
extern TraceEvent _TRACE_MEMORY_REGION_SUBPAGE_WRITE_EVENT;
extern TraceEvent _TRACE_MEMORY_REGION_RAM_DEVICE_READ_EVENT;
extern TraceEvent _TRACE_MEMORY_REGION_RAM_DEVICE_WRITE_EVENT;
extern TraceEvent _TRACE_MEMORY_REGION_SYNC_DIRTY_EVENT;
extern TraceEvent _TRACE_FLATVIEW_NEW_EVENT;
extern TraceEvent _TRACE_FLATVIEW_DESTROY_EVENT;
extern TraceEvent _TRACE_FLATVIEW_DESTROY_RCU_EVENT;
extern TraceEvent _TRACE_GLOBAL_DIRTY_CHANGED_EVENT;
extern TraceEvent _TRACE_ADDRESS_SPACE_MAP_EVENT;
extern TraceEvent _TRACE_FIND_RAM_OFFSET_EVENT;
extern TraceEvent _TRACE_FIND_RAM_OFFSET_LOOP_EVENT;
extern TraceEvent _TRACE_RAM_BLOCK_DISCARD_RANGE_EVENT;
extern TraceEvent _TRACE_QEMU_RAM_ALLOC_SHARED_EVENT;
extern TraceEvent _TRACE_VM_STOP_FLUSH_ALL_EVENT;
extern TraceEvent _TRACE_VM_STATE_NOTIFY_EVENT;
extern TraceEvent _TRACE_LOAD_FILE_EVENT;
extern TraceEvent _TRACE_RUNSTATE_SET_EVENT;
extern TraceEvent _TRACE_SYSTEM_WAKEUP_REQUEST_EVENT;
extern TraceEvent _TRACE_QEMU_SYSTEM_SHUTDOWN_REQUEST_EVENT;
extern TraceEvent _TRACE_QEMU_SYSTEM_POWERDOWN_REQUEST_EVENT;
extern TraceEvent _TRACE_DIRTYLIMIT_STATE_INITIALIZE_EVENT;
extern TraceEvent _TRACE_DIRTYLIMIT_STATE_FINALIZE_EVENT;
extern TraceEvent _TRACE_DIRTYLIMIT_THROTTLE_PCT_EVENT;
extern TraceEvent _TRACE_DIRTYLIMIT_SET_VCPU_EVENT;
extern TraceEvent _TRACE_DIRTYLIMIT_VCPU_EXECUTE_EVENT;
extern uint16_t _TRACE_BALLOON_EVENT_DSTATE;
extern uint16_t _TRACE_DMA_BLK_IO_DSTATE;
extern uint16_t _TRACE_DMA_AIO_CANCEL_DSTATE;
extern uint16_t _TRACE_DMA_COMPLETE_DSTATE;
extern uint16_t _TRACE_DMA_BLK_CB_DSTATE;
extern uint16_t _TRACE_DMA_MAP_WAIT_DSTATE;
extern uint16_t _TRACE_CPU_IN_DSTATE;
extern uint16_t _TRACE_CPU_OUT_DSTATE;
extern uint16_t _TRACE_MEMORY_REGION_OPS_READ_DSTATE;
extern uint16_t _TRACE_MEMORY_REGION_OPS_WRITE_DSTATE;
extern uint16_t _TRACE_MEMORY_REGION_SUBPAGE_READ_DSTATE;
extern uint16_t _TRACE_MEMORY_REGION_SUBPAGE_WRITE_DSTATE;
extern uint16_t _TRACE_MEMORY_REGION_RAM_DEVICE_READ_DSTATE;
extern uint16_t _TRACE_MEMORY_REGION_RAM_DEVICE_WRITE_DSTATE;
extern uint16_t _TRACE_MEMORY_REGION_SYNC_DIRTY_DSTATE;
extern uint16_t _TRACE_FLATVIEW_NEW_DSTATE;
extern uint16_t _TRACE_FLATVIEW_DESTROY_DSTATE;
extern uint16_t _TRACE_FLATVIEW_DESTROY_RCU_DSTATE;
extern uint16_t _TRACE_GLOBAL_DIRTY_CHANGED_DSTATE;
extern uint16_t _TRACE_ADDRESS_SPACE_MAP_DSTATE;
extern uint16_t _TRACE_FIND_RAM_OFFSET_DSTATE;
extern uint16_t _TRACE_FIND_RAM_OFFSET_LOOP_DSTATE;
extern uint16_t _TRACE_RAM_BLOCK_DISCARD_RANGE_DSTATE;
extern uint16_t _TRACE_QEMU_RAM_ALLOC_SHARED_DSTATE;
extern uint16_t _TRACE_VM_STOP_FLUSH_ALL_DSTATE;
extern uint16_t _TRACE_VM_STATE_NOTIFY_DSTATE;
extern uint16_t _TRACE_LOAD_FILE_DSTATE;
extern uint16_t _TRACE_RUNSTATE_SET_DSTATE;
extern uint16_t _TRACE_SYSTEM_WAKEUP_REQUEST_DSTATE;
extern uint16_t _TRACE_QEMU_SYSTEM_SHUTDOWN_REQUEST_DSTATE;
extern uint16_t _TRACE_QEMU_SYSTEM_POWERDOWN_REQUEST_DSTATE;
extern uint16_t _TRACE_DIRTYLIMIT_STATE_INITIALIZE_DSTATE;
extern uint16_t _TRACE_DIRTYLIMIT_STATE_FINALIZE_DSTATE;
extern uint16_t _TRACE_DIRTYLIMIT_THROTTLE_PCT_DSTATE;
extern uint16_t _TRACE_DIRTYLIMIT_SET_VCPU_DSTATE;
extern uint16_t _TRACE_DIRTYLIMIT_VCPU_EXECUTE_DSTATE;
#define TRACE_BALLOON_EVENT_ENABLED 1
#define TRACE_DMA_BLK_IO_ENABLED 1
#define TRACE_DMA_AIO_CANCEL_ENABLED 1
#define TRACE_DMA_COMPLETE_ENABLED 1
#define TRACE_DMA_BLK_CB_ENABLED 1
#define TRACE_DMA_MAP_WAIT_ENABLED 1
#define TRACE_CPU_IN_ENABLED 1
#define TRACE_CPU_OUT_ENABLED 1
#define TRACE_MEMORY_REGION_OPS_READ_ENABLED 1
#define TRACE_MEMORY_REGION_OPS_WRITE_ENABLED 1
#define TRACE_MEMORY_REGION_SUBPAGE_READ_ENABLED 1
#define TRACE_MEMORY_REGION_SUBPAGE_WRITE_ENABLED 1
#define TRACE_MEMORY_REGION_RAM_DEVICE_READ_ENABLED 1
#define TRACE_MEMORY_REGION_RAM_DEVICE_WRITE_ENABLED 1
#define TRACE_MEMORY_REGION_SYNC_DIRTY_ENABLED 1
#define TRACE_FLATVIEW_NEW_ENABLED 1
#define TRACE_FLATVIEW_DESTROY_ENABLED 1
#define TRACE_FLATVIEW_DESTROY_RCU_ENABLED 1
#define TRACE_GLOBAL_DIRTY_CHANGED_ENABLED 1
#define TRACE_ADDRESS_SPACE_MAP_ENABLED 1
#define TRACE_FIND_RAM_OFFSET_ENABLED 1
#define TRACE_FIND_RAM_OFFSET_LOOP_ENABLED 1
#define TRACE_RAM_BLOCK_DISCARD_RANGE_ENABLED 1
#define TRACE_QEMU_RAM_ALLOC_SHARED_ENABLED 1
#define TRACE_VM_STOP_FLUSH_ALL_ENABLED 1
#define TRACE_VM_STATE_NOTIFY_ENABLED 1
#define TRACE_LOAD_FILE_ENABLED 1
#define TRACE_RUNSTATE_SET_ENABLED 1
#define TRACE_SYSTEM_WAKEUP_REQUEST_ENABLED 1
#define TRACE_QEMU_SYSTEM_SHUTDOWN_REQUEST_ENABLED 1
#define TRACE_QEMU_SYSTEM_POWERDOWN_REQUEST_ENABLED 1
#define TRACE_DIRTYLIMIT_STATE_INITIALIZE_ENABLED 1
#define TRACE_DIRTYLIMIT_STATE_FINALIZE_ENABLED 1
#define TRACE_DIRTYLIMIT_THROTTLE_PCT_ENABLED 1
#define TRACE_DIRTYLIMIT_SET_VCPU_ENABLED 1
#define TRACE_DIRTYLIMIT_VCPU_EXECUTE_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_BALLOON_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BALLOON_EVENT) || \
    false)

static inline void _nocheck__trace_balloon_event(void * opaque, unsigned long addr)
{
    if (trace_event_get_state(TRACE_BALLOON_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:balloon_event " "opaque %p addr %lu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , opaque, addr);
#line 136 "trace/trace-system.h"
        } else {
#line 5 "../system/trace-events"
            qemu_log("balloon_event " "opaque %p addr %lu" "\n", opaque, addr);
#line 140 "trace/trace-system.h"
        }
    }
}

static inline void trace_balloon_event(void * opaque, unsigned long addr)
{
    if (true) {
        _nocheck__trace_balloon_event(opaque, addr);
    }
}

#define TRACE_DMA_BLK_IO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DMA_BLK_IO) || \
    false)

static inline void _nocheck__trace_dma_blk_io(void * dbs, void * bs, int64_t offset, bool to_dev)
{
    if (trace_event_get_state(TRACE_DMA_BLK_IO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:dma_blk_io " "dbs=%p bs=%p offset=%" PRId64 " to_dev=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dbs, bs, offset, to_dev);
#line 167 "trace/trace-system.h"
        } else {
#line 8 "../system/trace-events"
            qemu_log("dma_blk_io " "dbs=%p bs=%p offset=%" PRId64 " to_dev=%d" "\n", dbs, bs, offset, to_dev);
#line 171 "trace/trace-system.h"
        }
    }
}

static inline void trace_dma_blk_io(void * dbs, void * bs, int64_t offset, bool to_dev)
{
    if (true) {
        _nocheck__trace_dma_blk_io(dbs, bs, offset, to_dev);
    }
}

#define TRACE_DMA_AIO_CANCEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DMA_AIO_CANCEL) || \
    false)

static inline void _nocheck__trace_dma_aio_cancel(void * dbs)
{
    if (trace_event_get_state(TRACE_DMA_AIO_CANCEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:dma_aio_cancel " "dbs=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dbs);
#line 198 "trace/trace-system.h"
        } else {
#line 9 "../system/trace-events"
            qemu_log("dma_aio_cancel " "dbs=%p" "\n", dbs);
#line 202 "trace/trace-system.h"
        }
    }
}

static inline void trace_dma_aio_cancel(void * dbs)
{
    if (true) {
        _nocheck__trace_dma_aio_cancel(dbs);
    }
}

#define TRACE_DMA_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DMA_COMPLETE) || \
    false)

static inline void _nocheck__trace_dma_complete(void * dbs, int ret, void * cb)
{
    if (trace_event_get_state(TRACE_DMA_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:dma_complete " "dbs=%p ret=%d cb=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dbs, ret, cb);
#line 229 "trace/trace-system.h"
        } else {
#line 10 "../system/trace-events"
            qemu_log("dma_complete " "dbs=%p ret=%d cb=%p" "\n", dbs, ret, cb);
#line 233 "trace/trace-system.h"
        }
    }
}

static inline void trace_dma_complete(void * dbs, int ret, void * cb)
{
    if (true) {
        _nocheck__trace_dma_complete(dbs, ret, cb);
    }
}

#define TRACE_DMA_BLK_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DMA_BLK_CB) || \
    false)

static inline void _nocheck__trace_dma_blk_cb(void * dbs, int ret)
{
    if (trace_event_get_state(TRACE_DMA_BLK_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 11 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:dma_blk_cb " "dbs=%p ret=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dbs, ret);
#line 260 "trace/trace-system.h"
        } else {
#line 11 "../system/trace-events"
            qemu_log("dma_blk_cb " "dbs=%p ret=%d" "\n", dbs, ret);
#line 264 "trace/trace-system.h"
        }
    }
}

static inline void trace_dma_blk_cb(void * dbs, int ret)
{
    if (true) {
        _nocheck__trace_dma_blk_cb(dbs, ret);
    }
}

#define TRACE_DMA_MAP_WAIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DMA_MAP_WAIT) || \
    false)

static inline void _nocheck__trace_dma_map_wait(void * dbs)
{
    if (trace_event_get_state(TRACE_DMA_MAP_WAIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 12 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:dma_map_wait " "dbs=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dbs);
#line 291 "trace/trace-system.h"
        } else {
#line 12 "../system/trace-events"
            qemu_log("dma_map_wait " "dbs=%p" "\n", dbs);
#line 295 "trace/trace-system.h"
        }
    }
}

static inline void trace_dma_map_wait(void * dbs)
{
    if (true) {
        _nocheck__trace_dma_map_wait(dbs);
    }
}

#define TRACE_CPU_IN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPU_IN) || \
    false)

static inline void _nocheck__trace_cpu_in(unsigned int addr, char size, unsigned int val)
{
    if (trace_event_get_state(TRACE_CPU_IN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:cpu_in " "addr 0x%x(%c) value %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size, val);
#line 322 "trace/trace-system.h"
        } else {
#line 15 "../system/trace-events"
            qemu_log("cpu_in " "addr 0x%x(%c) value %u" "\n", addr, size, val);
#line 326 "trace/trace-system.h"
        }
    }
}

static inline void trace_cpu_in(unsigned int addr, char size, unsigned int val)
{
    if (true) {
        _nocheck__trace_cpu_in(addr, size, val);
    }
}

#define TRACE_CPU_OUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPU_OUT) || \
    false)

static inline void _nocheck__trace_cpu_out(unsigned int addr, char size, unsigned int val)
{
    if (trace_event_get_state(TRACE_CPU_OUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:cpu_out " "addr 0x%x(%c) value %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size, val);
#line 353 "trace/trace-system.h"
        } else {
#line 16 "../system/trace-events"
            qemu_log("cpu_out " "addr 0x%x(%c) value %u" "\n", addr, size, val);
#line 357 "trace/trace-system.h"
        }
    }
}

static inline void trace_cpu_out(unsigned int addr, char size, unsigned int val)
{
    if (true) {
        _nocheck__trace_cpu_out(addr, size, val);
    }
}

#define TRACE_MEMORY_REGION_OPS_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEMORY_REGION_OPS_READ) || \
    false)

static inline void _nocheck__trace_memory_region_ops_read(int cpu_index, void * mr, uint64_t addr, uint64_t value, unsigned size, const char * name)
{
    if (trace_event_get_state(TRACE_MEMORY_REGION_OPS_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:memory_region_ops_read " "cpu %d mr %p addr 0x%"PRIx64" value 0x%"PRIx64" size %u name '%s'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cpu_index, mr, addr, value, size, name);
#line 384 "trace/trace-system.h"
        } else {
#line 19 "../system/trace-events"
            qemu_log("memory_region_ops_read " "cpu %d mr %p addr 0x%"PRIx64" value 0x%"PRIx64" size %u name '%s'" "\n", cpu_index, mr, addr, value, size, name);
#line 388 "trace/trace-system.h"
        }
    }
}

static inline void trace_memory_region_ops_read(int cpu_index, void * mr, uint64_t addr, uint64_t value, unsigned size, const char * name)
{
    if (true) {
        _nocheck__trace_memory_region_ops_read(cpu_index, mr, addr, value, size, name);
    }
}

#define TRACE_MEMORY_REGION_OPS_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEMORY_REGION_OPS_WRITE) || \
    false)

static inline void _nocheck__trace_memory_region_ops_write(int cpu_index, void * mr, uint64_t addr, uint64_t value, unsigned size, const char * name)
{
    if (trace_event_get_state(TRACE_MEMORY_REGION_OPS_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:memory_region_ops_write " "cpu %d mr %p addr 0x%"PRIx64" value 0x%"PRIx64" size %u name '%s'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cpu_index, mr, addr, value, size, name);
#line 415 "trace/trace-system.h"
        } else {
#line 20 "../system/trace-events"
            qemu_log("memory_region_ops_write " "cpu %d mr %p addr 0x%"PRIx64" value 0x%"PRIx64" size %u name '%s'" "\n", cpu_index, mr, addr, value, size, name);
#line 419 "trace/trace-system.h"
        }
    }
}

static inline void trace_memory_region_ops_write(int cpu_index, void * mr, uint64_t addr, uint64_t value, unsigned size, const char * name)
{
    if (true) {
        _nocheck__trace_memory_region_ops_write(cpu_index, mr, addr, value, size, name);
    }
}

#define TRACE_MEMORY_REGION_SUBPAGE_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEMORY_REGION_SUBPAGE_READ) || \
    false)

static inline void _nocheck__trace_memory_region_subpage_read(int cpu_index, void * mr, uint64_t offset, uint64_t value, unsigned size)
{
    if (trace_event_get_state(TRACE_MEMORY_REGION_SUBPAGE_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:memory_region_subpage_read " "cpu %d mr %p offset 0x%"PRIx64" value 0x%"PRIx64" size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cpu_index, mr, offset, value, size);
#line 446 "trace/trace-system.h"
        } else {
#line 21 "../system/trace-events"
            qemu_log("memory_region_subpage_read " "cpu %d mr %p offset 0x%"PRIx64" value 0x%"PRIx64" size %u" "\n", cpu_index, mr, offset, value, size);
#line 450 "trace/trace-system.h"
        }
    }
}

static inline void trace_memory_region_subpage_read(int cpu_index, void * mr, uint64_t offset, uint64_t value, unsigned size)
{
    if (true) {
        _nocheck__trace_memory_region_subpage_read(cpu_index, mr, offset, value, size);
    }
}

#define TRACE_MEMORY_REGION_SUBPAGE_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEMORY_REGION_SUBPAGE_WRITE) || \
    false)

static inline void _nocheck__trace_memory_region_subpage_write(int cpu_index, void * mr, uint64_t offset, uint64_t value, unsigned size)
{
    if (trace_event_get_state(TRACE_MEMORY_REGION_SUBPAGE_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:memory_region_subpage_write " "cpu %d mr %p offset 0x%"PRIx64" value 0x%"PRIx64" size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cpu_index, mr, offset, value, size);
#line 477 "trace/trace-system.h"
        } else {
#line 22 "../system/trace-events"
            qemu_log("memory_region_subpage_write " "cpu %d mr %p offset 0x%"PRIx64" value 0x%"PRIx64" size %u" "\n", cpu_index, mr, offset, value, size);
#line 481 "trace/trace-system.h"
        }
    }
}

static inline void trace_memory_region_subpage_write(int cpu_index, void * mr, uint64_t offset, uint64_t value, unsigned size)
{
    if (true) {
        _nocheck__trace_memory_region_subpage_write(cpu_index, mr, offset, value, size);
    }
}

#define TRACE_MEMORY_REGION_RAM_DEVICE_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEMORY_REGION_RAM_DEVICE_READ) || \
    false)

static inline void _nocheck__trace_memory_region_ram_device_read(int cpu_index, void * mr, uint64_t addr, uint64_t value, unsigned size)
{
    if (trace_event_get_state(TRACE_MEMORY_REGION_RAM_DEVICE_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 23 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:memory_region_ram_device_read " "cpu %d mr %p addr 0x%"PRIx64" value 0x%"PRIx64" size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cpu_index, mr, addr, value, size);
#line 508 "trace/trace-system.h"
        } else {
#line 23 "../system/trace-events"
            qemu_log("memory_region_ram_device_read " "cpu %d mr %p addr 0x%"PRIx64" value 0x%"PRIx64" size %u" "\n", cpu_index, mr, addr, value, size);
#line 512 "trace/trace-system.h"
        }
    }
}

static inline void trace_memory_region_ram_device_read(int cpu_index, void * mr, uint64_t addr, uint64_t value, unsigned size)
{
    if (true) {
        _nocheck__trace_memory_region_ram_device_read(cpu_index, mr, addr, value, size);
    }
}

#define TRACE_MEMORY_REGION_RAM_DEVICE_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEMORY_REGION_RAM_DEVICE_WRITE) || \
    false)

static inline void _nocheck__trace_memory_region_ram_device_write(int cpu_index, void * mr, uint64_t addr, uint64_t value, unsigned size)
{
    if (trace_event_get_state(TRACE_MEMORY_REGION_RAM_DEVICE_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:memory_region_ram_device_write " "cpu %d mr %p addr 0x%"PRIx64" value 0x%"PRIx64" size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cpu_index, mr, addr, value, size);
#line 539 "trace/trace-system.h"
        } else {
#line 24 "../system/trace-events"
            qemu_log("memory_region_ram_device_write " "cpu %d mr %p addr 0x%"PRIx64" value 0x%"PRIx64" size %u" "\n", cpu_index, mr, addr, value, size);
#line 543 "trace/trace-system.h"
        }
    }
}

static inline void trace_memory_region_ram_device_write(int cpu_index, void * mr, uint64_t addr, uint64_t value, unsigned size)
{
    if (true) {
        _nocheck__trace_memory_region_ram_device_write(cpu_index, mr, addr, value, size);
    }
}

#define TRACE_MEMORY_REGION_SYNC_DIRTY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEMORY_REGION_SYNC_DIRTY) || \
    false)

static inline void _nocheck__trace_memory_region_sync_dirty(const char * mr, const char * listener, int global)
{
    if (trace_event_get_state(TRACE_MEMORY_REGION_SYNC_DIRTY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:memory_region_sync_dirty " "mr '%s' listener '%s' synced (global=%d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , mr, listener, global);
#line 570 "trace/trace-system.h"
        } else {
#line 25 "../system/trace-events"
            qemu_log("memory_region_sync_dirty " "mr '%s' listener '%s' synced (global=%d)" "\n", mr, listener, global);
#line 574 "trace/trace-system.h"
        }
    }
}

static inline void trace_memory_region_sync_dirty(const char * mr, const char * listener, int global)
{
    if (true) {
        _nocheck__trace_memory_region_sync_dirty(mr, listener, global);
    }
}

#define TRACE_FLATVIEW_NEW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FLATVIEW_NEW) || \
    false)

static inline void _nocheck__trace_flatview_new(void * view, void * root)
{
    if (trace_event_get_state(TRACE_FLATVIEW_NEW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:flatview_new " "%p (root %p)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , view, root);
#line 601 "trace/trace-system.h"
        } else {
#line 26 "../system/trace-events"
            qemu_log("flatview_new " "%p (root %p)" "\n", view, root);
#line 605 "trace/trace-system.h"
        }
    }
}

static inline void trace_flatview_new(void * view, void * root)
{
    if (true) {
        _nocheck__trace_flatview_new(view, root);
    }
}

#define TRACE_FLATVIEW_DESTROY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FLATVIEW_DESTROY) || \
    false)

static inline void _nocheck__trace_flatview_destroy(void * view, void * root)
{
    if (trace_event_get_state(TRACE_FLATVIEW_DESTROY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:flatview_destroy " "%p (root %p)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , view, root);
#line 632 "trace/trace-system.h"
        } else {
#line 27 "../system/trace-events"
            qemu_log("flatview_destroy " "%p (root %p)" "\n", view, root);
#line 636 "trace/trace-system.h"
        }
    }
}

static inline void trace_flatview_destroy(void * view, void * root)
{
    if (true) {
        _nocheck__trace_flatview_destroy(view, root);
    }
}

#define TRACE_FLATVIEW_DESTROY_RCU_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FLATVIEW_DESTROY_RCU) || \
    false)

static inline void _nocheck__trace_flatview_destroy_rcu(void * view, void * root)
{
    if (trace_event_get_state(TRACE_FLATVIEW_DESTROY_RCU) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:flatview_destroy_rcu " "%p (root %p)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , view, root);
#line 663 "trace/trace-system.h"
        } else {
#line 28 "../system/trace-events"
            qemu_log("flatview_destroy_rcu " "%p (root %p)" "\n", view, root);
#line 667 "trace/trace-system.h"
        }
    }
}

static inline void trace_flatview_destroy_rcu(void * view, void * root)
{
    if (true) {
        _nocheck__trace_flatview_destroy_rcu(view, root);
    }
}

#define TRACE_GLOBAL_DIRTY_CHANGED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GLOBAL_DIRTY_CHANGED) || \
    false)

static inline void _nocheck__trace_global_dirty_changed(unsigned int bitmask)
{
    if (trace_event_get_state(TRACE_GLOBAL_DIRTY_CHANGED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:global_dirty_changed " "bitmask 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bitmask);
#line 694 "trace/trace-system.h"
        } else {
#line 29 "../system/trace-events"
            qemu_log("global_dirty_changed " "bitmask 0x%"PRIx32 "\n", bitmask);
#line 698 "trace/trace-system.h"
        }
    }
}

static inline void trace_global_dirty_changed(unsigned int bitmask)
{
    if (true) {
        _nocheck__trace_global_dirty_changed(bitmask);
    }
}

#define TRACE_ADDRESS_SPACE_MAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ADDRESS_SPACE_MAP) || \
    false)

static inline void _nocheck__trace_address_space_map(void * as, uint64_t addr, uint64_t len, bool is_write, uint32_t attrs)
{
    if (trace_event_get_state(TRACE_ADDRESS_SPACE_MAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:address_space_map " "as:%p addr 0x%"PRIx64":%"PRIx64" write:%d attrs:0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , as, addr, len, is_write, attrs);
#line 725 "trace/trace-system.h"
        } else {
#line 32 "../system/trace-events"
            qemu_log("address_space_map " "as:%p addr 0x%"PRIx64":%"PRIx64" write:%d attrs:0x%x" "\n", as, addr, len, is_write, attrs);
#line 729 "trace/trace-system.h"
        }
    }
}

static inline void trace_address_space_map(void * as, uint64_t addr, uint64_t len, bool is_write, uint32_t attrs)
{
    if (true) {
        _nocheck__trace_address_space_map(as, addr, len, is_write, attrs);
    }
}

#define TRACE_FIND_RAM_OFFSET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FIND_RAM_OFFSET) || \
    false)

static inline void _nocheck__trace_find_ram_offset(uint64_t size, uint64_t offset)
{
    if (trace_event_get_state(TRACE_FIND_RAM_OFFSET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 33 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:find_ram_offset " "size: 0x%" PRIx64 " @ 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , size, offset);
#line 756 "trace/trace-system.h"
        } else {
#line 33 "../system/trace-events"
            qemu_log("find_ram_offset " "size: 0x%" PRIx64 " @ 0x%" PRIx64 "\n", size, offset);
#line 760 "trace/trace-system.h"
        }
    }
}

static inline void trace_find_ram_offset(uint64_t size, uint64_t offset)
{
    if (true) {
        _nocheck__trace_find_ram_offset(size, offset);
    }
}

#define TRACE_FIND_RAM_OFFSET_LOOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FIND_RAM_OFFSET_LOOP) || \
    false)

static inline void _nocheck__trace_find_ram_offset_loop(uint64_t size, uint64_t candidate, uint64_t offset, uint64_t next, uint64_t mingap)
{
    if (trace_event_get_state(TRACE_FIND_RAM_OFFSET_LOOP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:find_ram_offset_loop " "trying size: 0x%" PRIx64 " @ 0x%" PRIx64 ", offset: 0x%" PRIx64" next: 0x%" PRIx64 " mingap: 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , size, candidate, offset, next, mingap);
#line 787 "trace/trace-system.h"
        } else {
#line 34 "../system/trace-events"
            qemu_log("find_ram_offset_loop " "trying size: 0x%" PRIx64 " @ 0x%" PRIx64 ", offset: 0x%" PRIx64" next: 0x%" PRIx64 " mingap: 0x%" PRIx64 "\n", size, candidate, offset, next, mingap);
#line 791 "trace/trace-system.h"
        }
    }
}

static inline void trace_find_ram_offset_loop(uint64_t size, uint64_t candidate, uint64_t offset, uint64_t next, uint64_t mingap)
{
    if (true) {
        _nocheck__trace_find_ram_offset_loop(size, candidate, offset, next, mingap);
    }
}

#define TRACE_RAM_BLOCK_DISCARD_RANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RAM_BLOCK_DISCARD_RANGE) || \
    false)

static inline void _nocheck__trace_ram_block_discard_range(const char * rbname, void * hva, size_t length, bool need_madvise, bool need_fallocate, int ret)
{
    if (trace_event_get_state(TRACE_RAM_BLOCK_DISCARD_RANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 35 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:ram_block_discard_range " "%s@%p + 0x%zx: madvise: %d fallocate: %d ret: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , rbname, hva, length, need_madvise, need_fallocate, ret);
#line 818 "trace/trace-system.h"
        } else {
#line 35 "../system/trace-events"
            qemu_log("ram_block_discard_range " "%s@%p + 0x%zx: madvise: %d fallocate: %d ret: %d" "\n", rbname, hva, length, need_madvise, need_fallocate, ret);
#line 822 "trace/trace-system.h"
        }
    }
}

static inline void trace_ram_block_discard_range(const char * rbname, void * hva, size_t length, bool need_madvise, bool need_fallocate, int ret)
{
    if (true) {
        _nocheck__trace_ram_block_discard_range(rbname, hva, length, need_madvise, need_fallocate, ret);
    }
}

#define TRACE_QEMU_RAM_ALLOC_SHARED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RAM_ALLOC_SHARED) || \
    false)

static inline void _nocheck__trace_qemu_ram_alloc_shared(const char * name, size_t size, size_t max_size, int fd, void * host)
{
    if (trace_event_get_state(TRACE_QEMU_RAM_ALLOC_SHARED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 36 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_ram_alloc_shared " "%s size %zu max_size %zu fd %d host %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, size, max_size, fd, host);
#line 849 "trace/trace-system.h"
        } else {
#line 36 "../system/trace-events"
            qemu_log("qemu_ram_alloc_shared " "%s size %zu max_size %zu fd %d host %p" "\n", name, size, max_size, fd, host);
#line 853 "trace/trace-system.h"
        }
    }
}

static inline void trace_qemu_ram_alloc_shared(const char * name, size_t size, size_t max_size, int fd, void * host)
{
    if (true) {
        _nocheck__trace_qemu_ram_alloc_shared(name, size, max_size, fd, host);
    }
}

#define TRACE_VM_STOP_FLUSH_ALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VM_STOP_FLUSH_ALL) || \
    false)

static inline void _nocheck__trace_vm_stop_flush_all(int ret)
{
    if (trace_event_get_state(TRACE_VM_STOP_FLUSH_ALL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 39 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:vm_stop_flush_all " "ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ret);
#line 880 "trace/trace-system.h"
        } else {
#line 39 "../system/trace-events"
            qemu_log("vm_stop_flush_all " "ret %d" "\n", ret);
#line 884 "trace/trace-system.h"
        }
    }
}

static inline void trace_vm_stop_flush_all(int ret)
{
    if (true) {
        _nocheck__trace_vm_stop_flush_all(ret);
    }
}

#define TRACE_VM_STATE_NOTIFY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VM_STATE_NOTIFY) || \
    false)

static inline void _nocheck__trace_vm_state_notify(int running, int reason, const char * reason_str)
{
    if (trace_event_get_state(TRACE_VM_STATE_NOTIFY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 42 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:vm_state_notify " "running %d reason %d (%s)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , running, reason, reason_str);
#line 911 "trace/trace-system.h"
        } else {
#line 42 "../system/trace-events"
            qemu_log("vm_state_notify " "running %d reason %d (%s)" "\n", running, reason, reason_str);
#line 915 "trace/trace-system.h"
        }
    }
}

static inline void trace_vm_state_notify(int running, int reason, const char * reason_str)
{
    if (true) {
        _nocheck__trace_vm_state_notify(running, reason, reason_str);
    }
}

#define TRACE_LOAD_FILE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LOAD_FILE) || \
    false)

static inline void _nocheck__trace_load_file(const char * name, const char * path)
{
    if (trace_event_get_state(TRACE_LOAD_FILE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 43 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:load_file " "name %s location %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, path);
#line 942 "trace/trace-system.h"
        } else {
#line 43 "../system/trace-events"
            qemu_log("load_file " "name %s location %s" "\n", name, path);
#line 946 "trace/trace-system.h"
        }
    }
}

static inline void trace_load_file(const char * name, const char * path)
{
    if (true) {
        _nocheck__trace_load_file(name, path);
    }
}

#define TRACE_RUNSTATE_SET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RUNSTATE_SET) || \
    false)

static inline void _nocheck__trace_runstate_set(int current_state, const char * current_state_str, int new_state, const char * new_state_str)
{
    if (trace_event_get_state(TRACE_RUNSTATE_SET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 44 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:runstate_set " "current_run_state %d (%s) new_state %d (%s)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , current_state, current_state_str, new_state, new_state_str);
#line 973 "trace/trace-system.h"
        } else {
#line 44 "../system/trace-events"
            qemu_log("runstate_set " "current_run_state %d (%s) new_state %d (%s)" "\n", current_state, current_state_str, new_state, new_state_str);
#line 977 "trace/trace-system.h"
        }
    }
}

static inline void trace_runstate_set(int current_state, const char * current_state_str, int new_state, const char * new_state_str)
{
    if (true) {
        _nocheck__trace_runstate_set(current_state, current_state_str, new_state, new_state_str);
    }
}

#define TRACE_SYSTEM_WAKEUP_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SYSTEM_WAKEUP_REQUEST) || \
    false)

static inline void _nocheck__trace_system_wakeup_request(int reason)
{
    if (trace_event_get_state(TRACE_SYSTEM_WAKEUP_REQUEST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 45 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:system_wakeup_request " "reason=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reason);
#line 1004 "trace/trace-system.h"
        } else {
#line 45 "../system/trace-events"
            qemu_log("system_wakeup_request " "reason=%d" "\n", reason);
#line 1008 "trace/trace-system.h"
        }
    }
}

static inline void trace_system_wakeup_request(int reason)
{
    if (true) {
        _nocheck__trace_system_wakeup_request(reason);
    }
}

#define TRACE_QEMU_SYSTEM_SHUTDOWN_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_SYSTEM_SHUTDOWN_REQUEST) || \
    false)

static inline void _nocheck__trace_qemu_system_shutdown_request(int reason)
{
    if (trace_event_get_state(TRACE_QEMU_SYSTEM_SHUTDOWN_REQUEST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_system_shutdown_request " "reason=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reason);
#line 1035 "trace/trace-system.h"
        } else {
#line 46 "../system/trace-events"
            qemu_log("qemu_system_shutdown_request " "reason=%d" "\n", reason);
#line 1039 "trace/trace-system.h"
        }
    }
}

static inline void trace_qemu_system_shutdown_request(int reason)
{
    if (true) {
        _nocheck__trace_qemu_system_shutdown_request(reason);
    }
}

#define TRACE_QEMU_SYSTEM_POWERDOWN_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_SYSTEM_POWERDOWN_REQUEST) || \
    false)

static inline void _nocheck__trace_qemu_system_powerdown_request(void)
{
    if (trace_event_get_state(TRACE_QEMU_SYSTEM_POWERDOWN_REQUEST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 47 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_system_powerdown_request " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1066 "trace/trace-system.h"
        } else {
#line 47 "../system/trace-events"
            qemu_log("qemu_system_powerdown_request " "" "\n");
#line 1070 "trace/trace-system.h"
        }
    }
}

static inline void trace_qemu_system_powerdown_request(void)
{
    if (true) {
        _nocheck__trace_qemu_system_powerdown_request();
    }
}

#define TRACE_DIRTYLIMIT_STATE_INITIALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DIRTYLIMIT_STATE_INITIALIZE) || \
    false)

static inline void _nocheck__trace_dirtylimit_state_initialize(int max_cpus)
{
    if (trace_event_get_state(TRACE_DIRTYLIMIT_STATE_INITIALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 50 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:dirtylimit_state_initialize " "dirtylimit state initialize: max cpus %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , max_cpus);
#line 1097 "trace/trace-system.h"
        } else {
#line 50 "../system/trace-events"
            qemu_log("dirtylimit_state_initialize " "dirtylimit state initialize: max cpus %d" "\n", max_cpus);
#line 1101 "trace/trace-system.h"
        }
    }
}

static inline void trace_dirtylimit_state_initialize(int max_cpus)
{
    if (true) {
        _nocheck__trace_dirtylimit_state_initialize(max_cpus);
    }
}

#define TRACE_DIRTYLIMIT_STATE_FINALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DIRTYLIMIT_STATE_FINALIZE) || \
    false)

static inline void _nocheck__trace_dirtylimit_state_finalize(void)
{
    if (trace_event_get_state(TRACE_DIRTYLIMIT_STATE_FINALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 51 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:dirtylimit_state_finalize "  "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1128 "trace/trace-system.h"
        } else {
#line 51 "../system/trace-events"
            qemu_log("dirtylimit_state_finalize "  "\n");
#line 1132 "trace/trace-system.h"
        }
    }
}

static inline void trace_dirtylimit_state_finalize(void)
{
    if (true) {
        _nocheck__trace_dirtylimit_state_finalize();
    }
}

#define TRACE_DIRTYLIMIT_THROTTLE_PCT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DIRTYLIMIT_THROTTLE_PCT) || \
    false)

static inline void _nocheck__trace_dirtylimit_throttle_pct(int cpu_index, uint64_t pct, int64_t time_us)
{
    if (trace_event_get_state(TRACE_DIRTYLIMIT_THROTTLE_PCT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 52 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:dirtylimit_throttle_pct " "CPU[%d] throttle percent: %" PRIu64 ", throttle adjust time %"PRIi64 " us" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cpu_index, pct, time_us);
#line 1159 "trace/trace-system.h"
        } else {
#line 52 "../system/trace-events"
            qemu_log("dirtylimit_throttle_pct " "CPU[%d] throttle percent: %" PRIu64 ", throttle adjust time %"PRIi64 " us" "\n", cpu_index, pct, time_us);
#line 1163 "trace/trace-system.h"
        }
    }
}

static inline void trace_dirtylimit_throttle_pct(int cpu_index, uint64_t pct, int64_t time_us)
{
    if (true) {
        _nocheck__trace_dirtylimit_throttle_pct(cpu_index, pct, time_us);
    }
}

#define TRACE_DIRTYLIMIT_SET_VCPU_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DIRTYLIMIT_SET_VCPU) || \
    false)

static inline void _nocheck__trace_dirtylimit_set_vcpu(int cpu_index, uint64_t quota)
{
    if (trace_event_get_state(TRACE_DIRTYLIMIT_SET_VCPU) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:dirtylimit_set_vcpu " "CPU[%d] set dirty page rate limit %"PRIu64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cpu_index, quota);
#line 1190 "trace/trace-system.h"
        } else {
#line 53 "../system/trace-events"
            qemu_log("dirtylimit_set_vcpu " "CPU[%d] set dirty page rate limit %"PRIu64 "\n", cpu_index, quota);
#line 1194 "trace/trace-system.h"
        }
    }
}

static inline void trace_dirtylimit_set_vcpu(int cpu_index, uint64_t quota)
{
    if (true) {
        _nocheck__trace_dirtylimit_set_vcpu(cpu_index, quota);
    }
}

#define TRACE_DIRTYLIMIT_VCPU_EXECUTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DIRTYLIMIT_VCPU_EXECUTE) || \
    false)

static inline void _nocheck__trace_dirtylimit_vcpu_execute(int cpu_index, int64_t sleep_time_us)
{
    if (trace_event_get_state(TRACE_DIRTYLIMIT_VCPU_EXECUTE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 54 "../system/trace-events"
            qemu_log("%d@%zu.%06zu:dirtylimit_vcpu_execute " "CPU[%d] sleep %"PRIi64 " us" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cpu_index, sleep_time_us);
#line 1221 "trace/trace-system.h"
        } else {
#line 54 "../system/trace-events"
            qemu_log("dirtylimit_vcpu_execute " "CPU[%d] sleep %"PRIi64 " us" "\n", cpu_index, sleep_time_us);
#line 1225 "trace/trace-system.h"
        }
    }
}

static inline void trace_dirtylimit_vcpu_execute(int cpu_index, int64_t sleep_time_us)
{
    if (true) {
        _nocheck__trace_dirtylimit_vcpu_execute(cpu_index, sleep_time_us);
    }
}
#endif /* TRACE_SYSTEM_GENERATED_TRACERS_H */
